mgl2_8.0.1_(mathgl)/C-include/volume.h: *   License along with this program; if not, write to the                 *
mgl2_8.0.1_(mathgl)/C-include/canvas_cf.h: *   License along with this program; if not, write to the                 *
mgl2_8.0.1_(mathgl)/C-include/canvas_cf.h:long MGL_EXPORT_PURE mgl_is_active(HMGL gr, int xs, int ys, int d);
mgl2_8.0.1_(mathgl)/C-include/canvas_cf.h:long MGL_EXPORT_PURE mgl_is_active_(uintptr_t *gr, int *xs, int *ys, int *d);
mgl2_8.0.1_(mathgl)/C-include/canvas_cf.h:long MGL_EXPORT mgl_use_parser(HMPR p, int inc);
mgl2_8.0.1_(mathgl)/C-include/canvas_cf.h:long MGL_EXPORT mgl_use_parser_(uintptr_t* , int *inc);
mgl2_8.0.1_(mathgl)/C-include/canvas_cf.h:MGL_EXPORT_PURE mglDataA *mgl_parser_get_var(HMPR p, unsigned long id);
mgl2_8.0.1_(mathgl)/C-include/canvas_cf.h:uintptr_t MGL_EXPORT_PURE mgl_parser_get_var_(uintptr_t* p, unsigned long *id);
mgl2_8.0.1_(mathgl)/C-include/canvas_cf.h:long MGL_EXPORT_PURE mgl_parser_num_var(HMPR p);
mgl2_8.0.1_(mathgl)/C-include/canvas_cf.h:long MGL_EXPORT_PURE mgl_parser_num_var_(uintptr_t* p);
mgl2_8.0.1_(mathgl)/C-include/canvas_cf.h:MGL_EXPORT_PURE mglNum *mgl_parser_get_const(HMPR p, unsigned long id);
mgl2_8.0.1_(mathgl)/C-include/canvas_cf.h:uintptr_t MGL_EXPORT_PURE mgl_parser_get_const_(uintptr_t* p, unsigned long *id);
mgl2_8.0.1_(mathgl)/C-include/canvas_cf.h:long MGL_EXPORT_PURE mgl_parser_num_const(HMPR p);
mgl2_8.0.1_(mathgl)/C-include/canvas_cf.h:long MGL_EXPORT_PURE mgl_parser_num_const_(uintptr_t* p);
mgl2_8.0.1_(mathgl)/C-include/canvas_cf.h:MGL_EXPORT_PURE const char *mgl_parser_cmd_name(HMPR pr, long id);
mgl2_8.0.1_(mathgl)/C-include/canvas_cf.h:long MGL_EXPORT_PURE mgl_parser_cmd_num(HMPR pr);
mgl2_8.0.1_(mathgl)/C-include/pde.h: *   License along with this program; if not, write to the                 *
mgl2_8.0.1_(mathgl)/C-include/pde.h:/// Saves result of PDE solving for "Hamiltonian" ham with initial conditions ini along a curve ray (must have nx>=7 - x,y,z,px,py,pz,tau or nx=5 - x,y,px,py,tau)
mgl2_8.0.1_(mathgl)/C-include/pde.h:/// Saves result of PDE solving for "Hamiltonian" ham with initial conditions ini along a curve ray (must have nx>=7 - x,y,z,px,py,pz,tau or nx=5 - x,y,px,py,tau)
mgl2_8.0.1_(mathgl)/C-include/pde.h:/// Saves result of PDE solving for "Hamiltonian" ham with initial conditions ini along a curve ray (must have nx>=7 - x,y,z,px,py,pz,tau or nx=5 - x,y,px,py,tau)
mgl2_8.0.1_(mathgl)/C-include/pde.h:/// Saves result of PDE solving for "Hamiltonian" ham with initial conditions ini along a curve ray (must have nx>=7 - x,y,z,px,py,pz,tau or nx=5 - x,y,px,py,tau)
mgl2_8.0.1_(mathgl)/C-include/base_cf.h: *   License along with this program; if not, write to the                 *
mgl2_8.0.1_(mathgl)/C-include/base_cf.h:void MGL_EXPORT mgl_set_draw_reg(HMGL gr, long nx, long ny, long m);
mgl2_8.0.1_(mathgl)/C-include/base_cf.h:int MGL_EXPORT_PURE mgl_get_flag_(uintptr_t *gr, unsigned long *flag);
mgl2_8.0.1_(mathgl)/C-include/base_cf.h:void MGL_EXPORT mgl_set_flag_(uintptr_t *gr, int *val, unsigned long *flag);
mgl2_8.0.1_(mathgl)/C-include/base_cf.h:long MGL_EXPORT mgl_use_graph(HMGL gr, int inc);
mgl2_8.0.1_(mathgl)/C-include/base_cf.h:long MGL_EXPORT mgl_use_graph_(uintptr_t *gr, int *inc);
mgl2_8.0.1_(mathgl)/C-include/base_cf.h:/// Set mask for face coloring as unsigned long number
mgl2_8.0.1_(mathgl)/C-include/eval.h: *   License along with this program; if not, write to the                 *
mgl2_8.0.1_(mathgl)/C-include/qt.h: *   License along with this program; if not, write to the                 *
mgl2_8.0.1_(mathgl)/C-include/thread.h: *   License along with this program; if not, write to the                 *
mgl2_8.0.1_(mathgl)/C-include/thread.h:	const long *p;	// long* array with parameters
mgl2_8.0.1_(mathgl)/C-include/thread.h:	long n;			// total number of iteration
mgl2_8.0.1_(mathgl)/C-include/thread.h:	const long *p;	// long* array with parameters
mgl2_8.0.1_(mathgl)/C-include/thread.h:	long n;			// total number of iteration
mgl2_8.0.1_(mathgl)/C-include/thread.h:	const long *p;	// long* array with parameters
mgl2_8.0.1_(mathgl)/C-include/thread.h:	long n;			// total number of iteration
mgl2_8.0.1_(mathgl)/C-include/thread.h:	const long *p;	// long* array with parameters
mgl2_8.0.1_(mathgl)/C-include/thread.h:	long n;			// total number of iteration
mgl2_8.0.1_(mathgl)/C-include/thread.h:void MGL_EXPORT mglStartThread(void *(*func)(void *), void (*post)(mglThreadD *,mreal *), long n,
mgl2_8.0.1_(mathgl)/C-include/thread.h:					mreal *a=0, const mreal *b=0, const mreal *c=0, const long *p=0,
mgl2_8.0.1_(mathgl)/C-include/thread.h:void MGL_EXPORT mglStartThreadV(void *(*func)(void *), long n, mreal *a, const void *b=0,
mgl2_8.0.1_(mathgl)/C-include/thread.h:					const void *c=0, const long *p=0, const void *v=0, const mreal *d=0);
mgl2_8.0.1_(mathgl)/C-include/thread.h:void MGL_EXPORT mglStartThreadV(void *(*func)(void *), long n, dual *a, const void *b=0,
mgl2_8.0.1_(mathgl)/C-include/thread.h:					const void *c=0, const long *p=0, const void *v=0, const mreal *d=0);
mgl2_8.0.1_(mathgl)/C-include/thread.h:void MGL_EXPORT mglStartThreadC(void *(*func)(void *), void (*post)(mglThreadC *,dual *), long n,
mgl2_8.0.1_(mathgl)/C-include/thread.h:					dual *a=0, const dual *b=0, const dual *c=0, const long *p=0,
mgl2_8.0.1_(mathgl)/C-include/thread.h:void MGL_EXPORT mglStartThreadT(void *(*func)(void *), long n, void *a, double *b, const void *v=0,
mgl2_8.0.1_(mathgl)/C-include/thread.h:					void **w=0, const long *p=0, const void *re=0, const void *im=0);
mgl2_8.0.1_(mathgl)/C-include/canvas_wnd.h: *   License along with this program; if not, write to the                 *
mgl2_8.0.1_(mathgl)/C-include/canvas_wnd.h:	void SetFrame(long i);
mgl2_8.0.1_(mathgl)/C-include/canvas_wnd.h:	void DelFrame(long i);
mgl2_8.0.1_(mathgl)/C-include/opengl.h: *   License along with this program; if not, write to the                 *
mgl2_8.0.1_(mathgl)/C-include/opengl.h:	void DelFrame(long ){}*/
mgl2_8.0.1_(mathgl)/C-include/opengl.h:	void line_draw(long n1, long n2);
mgl2_8.0.1_(mathgl)/C-include/opengl.h:	void trig_draw(long n1, long n2, long n3);
mgl2_8.0.1_(mathgl)/C-include/opengl.h:	void quad_draw(long n1, long n2, long n3, long n4);
mgl2_8.0.1_(mathgl)/C-include/opengl.h:	unsigned char **GetRGBLines(long &w, long &h, unsigned char *&f, bool solid=true);
mgl2_8.0.1_(mathgl)/C-include/vect.h: *   License along with this program; if not, write to the                 *
mgl2_8.0.1_(mathgl)/C-include/vect.h:/// Plot vectors at position {x,y} along {ax,ay} with length/color proportional to |a|
mgl2_8.0.1_(mathgl)/C-include/vect.h:/// Plot vectors at position {x,y,z} along {ax,ay,az} with length/color proportional to |a|
mgl2_8.0.1_(mathgl)/C-include/vect.h: * ‘=’ for enabling color gradient along arrows. */
mgl2_8.0.1_(mathgl)/C-include/vect.h: * ‘=’ for enabling color gradient along arrows. */
mgl2_8.0.1_(mathgl)/C-include/vect.h: * ‘=’ for enabling color gradient along arrows. */
mgl2_8.0.1_(mathgl)/C-include/vect.h: * ‘=’ for enabling color gradient along arrows. */
mgl2_8.0.1_(mathgl)/C-include/vect.h:/// Draw vector plot along slice for 3d data specified parametrically
mgl2_8.0.1_(mathgl)/C-include/vect.h: * ‘=’ for enabling color gradient along arrows,
mgl2_8.0.1_(mathgl)/C-include/vect.h:/// Draw vector plot along slice for 3d data
mgl2_8.0.1_(mathgl)/C-include/vect.h: * ‘=’ for enabling color gradient along arrows,
mgl2_8.0.1_(mathgl)/C-include/mpi.h: *   along with this program; if not, write to the                         *
mgl2_8.0.1_(mathgl)/C-include/font.h: *   License along with this program; if not, write to the                 *
mgl2_8.0.1_(mathgl)/C-include/font.h:long MGL_EXPORT mgl_internal_code(unsigned s, const std::vector<mglGlyphDescr> &glyphs);
mgl2_8.0.1_(mathgl)/C-include/font.h:	inline long Internal(unsigned s) const	{	return mgl_internal_code(s,glyphs);	}
mgl2_8.0.1_(mathgl)/C-include/font.h:	inline const short *GetTr(int s, long j) const	{	return Buf+glyphs[j].tr[s];	}
mgl2_8.0.1_(mathgl)/C-include/font.h:	inline const short *GetLn(int s, long j) const	{	return Buf+glyphs[j].ln[s];	}
mgl2_8.0.1_(mathgl)/C-include/font.h:	inline int GetNt(int s, long j) const		{	return glyphs[j].numt[s];	}
mgl2_8.0.1_(mathgl)/C-include/font.h:	inline int GetNl(int s, long j) const		{	return glyphs[j].numl[s];	}
mgl2_8.0.1_(mathgl)/C-include/font.h:	inline short GetWidth(int s, long j) const	{	return glyphs[j].width[s];	}
mgl2_8.0.1_(mathgl)/C-include/font.h:	inline wchar_t GetUnicode(long j) const		{	return j>=0?glyphs[j].id:0;	}
mgl2_8.0.1_(mathgl)/C-include/font.h:	float get_ptr(long &i,unsigned *str, unsigned **b1, unsigned **b2,float &w1,float &w2, float f1, float f2, int st) const;
mgl2_8.0.1_(mathgl)/C-include/font.h:	inline void mem_alloc(long numg)	{	glyphs.resize(numg);	}
mgl2_8.0.1_(mathgl)/C-include/fit.h: *   License along with this program; if not, write to the                 *
mgl2_8.0.1_(mathgl)/C-include/fit.h:/// Fit data along x-direction for each data row. Return array with values for found formula.
mgl2_8.0.1_(mathgl)/C-include/fit.h:/// Fit data along x-, y-directions for each data slice. Return array with values for found formula.
mgl2_8.0.1_(mathgl)/C-include/fit.h:/// Fit data along along all directions. Return array with values for found formula.
mgl2_8.0.1_(mathgl)/C-include/fit.h:/// Fit data along x-direction for each data row. Return array with values for found formula.
mgl2_8.0.1_(mathgl)/C-include/fit.h:/// Fit data along x-, y-directions for each data slice. Return array with values for found formula.
mgl2_8.0.1_(mathgl)/C-include/fit.h:/// Fit data along along all directions. Return array with values for found formula.
mgl2_8.0.1_(mathgl)/C-include/fit.h:	/// Fit data with dispersion s along x-direction for each data row. Return array with values for found formula.
mgl2_8.0.1_(mathgl)/C-include/fit.h:	/// Fit data with dispersion s along x-, y-directions for each data slice. Return array with values for found formula.
mgl2_8.0.1_(mathgl)/C-include/glut.h: *   License along with this program; if not, write to the                 *
mgl2_8.0.1_(mathgl)/C-include/qmathgl.h: *   License along with this program; if not, write to the                 *
mgl2_8.0.1_(mathgl)/C-include/qmathgl.h:	long line;		///< Line which will be highlighted
mgl2_8.0.1_(mathgl)/C-include/define.h: *   License along with this program; if not, write to the                 *
mgl2_8.0.1_(mathgl)/C-include/define.h:// 4267	- conversion from 'size_t' to 'long,int,etc', possible loss of data
mgl2_8.0.1_(mathgl)/C-include/define.h:typedef signed long int32_t;
mgl2_8.0.1_(mathgl)/C-include/define.h:typedef signed long long int64_t;
mgl2_8.0.1_(mathgl)/C-include/define.h:typedef unsigned long uint32_t;
mgl2_8.0.1_(mathgl)/C-include/define.h:typedef unsigned long long uint64_t;
mgl2_8.0.1_(mathgl)/C-include/define.h:typedef unsigned long uintptr_t;
mgl2_8.0.1_(mathgl)/C-include/define.h:typedef long msize;
mgl2_8.0.1_(mathgl)/C-include/define.h:const unsigned long long mgl_nan[2] = {0x7fffffffffffffff, 0x7fffffff};
mgl2_8.0.1_(mathgl)/C-include/define.h:const unsigned long long mgl_inf[2] = {0x7ff0000000000000, 0x7f800000};
mgl2_8.0.1_(mathgl)/C-include/define.h:	mglScrLong,		// Too long line in MGL script
mgl2_8.0.1_(mathgl)/C-include/define.h:#define MGL_ENABLE_RTEXT 	0x00000008 	///< Use text rotation along axis
mgl2_8.0.1_(mathgl)/C-include/define.h:inline long mgl_int(double a)	{	return long(a+(a>=0?0.5:-0.5));	}
mgl2_8.0.1_(mathgl)/C-include/define.h:inline long mgl_imin(long a, long b)	{	return a>b?b:a;	}
mgl2_8.0.1_(mathgl)/C-include/define.h:inline long mgl_imax(long a, long b)	{	return a>b?a:b;	}
mgl2_8.0.1_(mathgl)/C-include/define.h:long MGL_EXPORT_PURE mgl_have_color(const char *stl);
mgl2_8.0.1_(mathgl)/C-include/wx.h: *   License along with this program; if not, write to the                 *
mgl2_8.0.1_(mathgl)/C-include/wx.h:	wxMathGL(wxWindow *parent, wxWindowID id=-1, const wxPoint& pos=wxDefaultPosition, const wxSize& size=wxDefaultSize, long style=0, const wxString& name=wxPanelNameStr);
mgl2_8.0.1_(mathgl)/C-include/datac.h: *   License along with this program; if not, write to the                 *
mgl2_8.0.1_(mathgl)/C-include/datac.h:dual MGL_EXPORT mglLinearC(const dual *a, long nx, long ny, long nz, mreal x, mreal y, mreal z);
mgl2_8.0.1_(mathgl)/C-include/datac.h:dual MGL_EXPORT mglSpline3C(const dual *a, long nx, long ny, long nz, mreal x, mreal y, mreal z,dual *dx=0, dual *dy=0, dual *dz=0);
mgl2_8.0.1_(mathgl)/C-include/datac.h:dual MGL_EXPORT mglSpline3Cs(const dual *a, long nx, long ny, long nz, mreal x, mreal y, mreal z);
mgl2_8.0.1_(mathgl)/C-include/datac.h:	long nx;		///< number of points in 1st dimensions ('x' dimension)
mgl2_8.0.1_(mathgl)/C-include/datac.h:	long ny;		///< number of points in 2nd dimensions ('y' dimension)
mgl2_8.0.1_(mathgl)/C-include/datac.h:	long nz;		///< number of points in 3d dimensions ('z' dimension)
mgl2_8.0.1_(mathgl)/C-include/datac.h:	mglDataC(long xx=1,long yy=1,long zz=1)	{	a=0;	Create(xx,yy,zz);	}
mgl2_8.0.1_(mathgl)/C-include/datac.h:	inline dual GetVal(long i, long j=0, long k=0) const
mgl2_8.0.1_(mathgl)/C-include/datac.h:	inline void SetVal(dual f, long i, long j=0, long k=0)
mgl2_8.0.1_(mathgl)/C-include/datac.h:	long GetNx() const	{	return nx;	}
mgl2_8.0.1_(mathgl)/C-include/datac.h:	long GetNy() const	{	return ny;	}
mgl2_8.0.1_(mathgl)/C-include/datac.h:	long GetNz() const	{	return nz;	}
mgl2_8.0.1_(mathgl)/C-include/datac.h:	inline void Link(dual *A, long NX, long NY=1, long NZ=1)
mgl2_8.0.1_(mathgl)/C-include/datac.h:	inline void Set(const float *A,long NX,long NY=1,long NZ=1)
mgl2_8.0.1_(mathgl)/C-include/datac.h:	inline void Set(const double *A,long NX,long NY=1,long NZ=1)
mgl2_8.0.1_(mathgl)/C-include/datac.h:	inline void Set(const dual *A,long NX,long NY=1,long NZ=1)
mgl2_8.0.1_(mathgl)/C-include/datac.h:	inline void Set(const char *str,long NX,long NY=1,long NZ=1)
mgl2_8.0.1_(mathgl)/C-include/datac.h:	{	if(d.size()>0)	{	Create(d.size());	for(long i=0;i<nx;i++)	a[i] = d[i];	}
mgl2_8.0.1_(mathgl)/C-include/datac.h:	{	if(d.size()>0)	{	Create(d.size());	for(long i=0;i<nx;i++)	a[i] = d[i];	}
mgl2_8.0.1_(mathgl)/C-include/datac.h:	{	if(d.size()>0)	{	Create(d.size());	for(long i=0;i<nx;i++)	a[i] = d[i];	}
mgl2_8.0.1_(mathgl)/C-include/datac.h:	{	Create(d.n_rows,d.n_cols);	for(long i=0;i<nx*ny;i++)	a[i] = d[i];	}
mgl2_8.0.1_(mathgl)/C-include/datac.h:	{	Create(d.n_rows,d.n_cols);	for(long i=0;i<nx*ny;i++)	a[i] = d[i];	}
mgl2_8.0.1_(mathgl)/C-include/datac.h:	{	Create(d.n_rows,d.n_cols,d.n_slices);	for(long i=0;i<nx*ny*nz;i++)	a[i] = d[i];	}
mgl2_8.0.1_(mathgl)/C-include/datac.h:	{	Create(d.n_rows,d.n_cols,d.n_slices);	for(long i=0;i<nx*ny*nz;i++)	a[i] = d[i];	}
mgl2_8.0.1_(mathgl)/C-include/datac.h:	{	Create(d.n_elem);	for(long i=0;i<nx;i++)	a[i] = d[i];	}
mgl2_8.0.1_(mathgl)/C-include/datac.h:	{	Create(d.n_elem);	for(long i=0;i<nx;i++)	a[i] = d[i];	}
mgl2_8.0.1_(mathgl)/C-include/datac.h:	inline arma::cx_mat arma_mat(long k=0) const { return arma::cx_mat(a+k*nx*ny,ny,nx);  }
mgl2_8.0.1_(mathgl)/C-include/datac.h:	inline void Create(long mx,long my=1,long mz=1)
mgl2_8.0.1_(mathgl)/C-include/datac.h:	inline void Rearrange(long mx, long my=0, long mz=0)
mgl2_8.0.1_(mathgl)/C-include/datac.h:	inline void Extend(long n1, long n2=0)
mgl2_8.0.1_(mathgl)/C-include/datac.h:	inline void Squeeze(long rx,long ry=1,long rz=1,bool smooth=false)
mgl2_8.0.1_(mathgl)/C-include/datac.h:	inline void Crop(long n1, long n2,char dir='x')
mgl2_8.0.1_(mathgl)/C-include/datac.h:	inline void Insert(char dir, long at=0, long num=1)
mgl2_8.0.1_(mathgl)/C-include/datac.h:	inline void Delete(char dir, long at=0, long num=1)
mgl2_8.0.1_(mathgl)/C-include/datac.h:	inline void Modify(const char *eq,long dim=0)
mgl2_8.0.1_(mathgl)/C-include/datac.h:	inline void RefillGS(const mglDataA &xdat, const mglDataA &vdat, mreal x1, mreal x2,long sl=-1)
mgl2_8.0.1_(mathgl)/C-include/datac.h:	inline void Refill(const mglDataA &xdat, const mglDataA &vdat, mreal x1, mreal x2,long sl=-1)
mgl2_8.0.1_(mathgl)/C-include/datac.h:	inline void Refill(const mglDataA &xdat, const mglDataA &vdat, mglPoint p1, mglPoint p2,long sl=-1)
mgl2_8.0.1_(mathgl)/C-include/datac.h:	inline void Refill(const mglDataA &xdat, const mglDataA &ydat, const mglDataA &vdat, mglPoint p1, mglPoint p2,long sl=-1)
mgl2_8.0.1_(mathgl)/C-include/datac.h:	inline void Refill(HMGL gr, const mglDataA &xdat, const mglDataA &vdat, long sl=-1, const char *opt="")
mgl2_8.0.1_(mathgl)/C-include/datac.h:	inline void Refill(HMGL gr, const mglDataA &xdat, const mglDataA &ydat, const mglDataA &vdat, long sl=-1, const char *opt="")
mgl2_8.0.1_(mathgl)/C-include/datac.h:	inline void Put(dual val, long i=-1, long j=-1, long k=-1)
mgl2_8.0.1_(mathgl)/C-include/datac.h:	inline void Put(const mglDataA &dat, long i=-1, long j=-1, long k=-1)
mgl2_8.0.1_(mathgl)/C-include/datac.h:	inline bool Read(const char *fname,long mx,long my=1,long mz=1)
mgl2_8.0.1_(mathgl)/C-include/datac.h:	void Save(const char *fname,long ns=-1) const
mgl2_8.0.1_(mathgl)/C-include/datac.h:	std::string Get(long ns=-1) const
mgl2_8.0.1_(mathgl)/C-include/datac.h:	inline bool ReadMat(const char *fname, long dim=2)
mgl2_8.0.1_(mathgl)/C-include/datac.h:	/// Get momentum (1D-array) of data along direction 'dir'. String looks like "x1" for median in x-direction, "x2" for width in x-dir and so on.
mgl2_8.0.1_(mathgl)/C-include/datac.h:	inline mglDataC SubData(long xx,long yy=-1,long zz=-1) const
mgl2_8.0.1_(mathgl)/C-include/datac.h:	/// Get data from sections ids, separated by value val along specified direction.
mgl2_8.0.1_(mathgl)/C-include/datac.h:	inline mglDataC Section(long id, char dir='y', mreal val=NAN) const
mgl2_8.0.1_(mathgl)/C-include/datac.h:	inline mglDataC Resize(long mx,long my=1,long mz=1, mreal x1=0,mreal x2=1, mreal y1=0,mreal y2=1, mreal z1=0,mreal z2=1) const
mgl2_8.0.1_(mathgl)/C-include/datac.h:	inline mglData Hist(long n,mreal v1=0,mreal v2=1, long nsub=0) const
mgl2_8.0.1_(mathgl)/C-include/datac.h:	inline mglData Hist(const mglDataA &w, long n,mreal v1=0,mreal v2=1, long nsub=0) const
mgl2_8.0.1_(mathgl)/C-include/datac.h:	/// Differentiate the parametrically specified data along direction v1
mgl2_8.0.1_(mathgl)/C-include/datac.h:	/// Differentiate the parametrically specified data along direction v1 with v2=const
mgl2_8.0.1_(mathgl)/C-include/datac.h:	/// Differentiate the parametrically specified data along direction v1 with v2,v3=const
mgl2_8.0.1_(mathgl)/C-include/datac.h:	/// Roll data along direction dir by num slices
mgl2_8.0.1_(mathgl)/C-include/datac.h:	inline void Roll(char dir, long num)	{	mgl_datac_roll(this,dir,num);	}
mgl2_8.0.1_(mathgl)/C-include/datac.h:	/// Keep the data phase/value along line i and j in given direction. 
mgl2_8.0.1_(mathgl)/C-include/datac.h:	inline void Keep(const char *how, long i, long j=0)
mgl2_8.0.1_(mathgl)/C-include/datac.h:	 * ‘x‘,‘y‘,‘z‘ or ‘r‘  for directions or axial along x,
mgl2_8.0.1_(mathgl)/C-include/datac.h:	inline mreal Solve(mreal val, bool use_spline=true, long i0=0) const
mgl2_8.0.1_(mathgl)/C-include/datac.h:		for(long i=0;i<nx*ny*nz;i++)	a[i]=val;	return val;	}
mgl2_8.0.1_(mathgl)/C-include/datac.h:		for(long i=0;i<nx*ny*nz;i++)	a[i]=val;	return val;	}
mgl2_8.0.1_(mathgl)/C-include/datac.h:	inline dual operator[](long i) const	{	return a[i];	}
mgl2_8.0.1_(mathgl)/C-include/datac.h:	inline dual &operator[](long i)			{	return a[i];	}
mgl2_8.0.1_(mathgl)/C-include/datac.h:	mreal v(long i,long j=0,long k=0) const	{	return abs(a[i+nx*(j+ny*k)]);	}
mgl2_8.0.1_(mathgl)/C-include/datac.h:	void set_v(mreal val, long i,long j=0,long k=0)	{	a[i+nx*(j+ny*k)]=val;	}
mgl2_8.0.1_(mathgl)/C-include/datac.h:	mreal v(long i,long j=0,long k=0) const	{	return abs(mgl_datac_get_value(this,i,j,k));	}
mgl2_8.0.1_(mathgl)/C-include/datac.h:	void set_v(mreal val, long i,long j=0,long k=0)	{	mgl_datac_set_value(this,val,i,j,k);	}
mgl2_8.0.1_(mathgl)/C-include/datac.h:	dual vc(long i,long j=0,long k=0) const	{	return a[i+nx*(j+ny*k)];	}
mgl2_8.0.1_(mathgl)/C-include/datac.h:	dual vcthr(long i) const	{	return a[i];	}
mgl2_8.0.1_(mathgl)/C-include/datac.h:	mreal vthr(long i) const {	return abs(a[i]);	}
mgl2_8.0.1_(mathgl)/C-include/datac.h:	mreal dvx(long i,long j=0,long k=0) const
mgl2_8.0.1_(mathgl)/C-include/datac.h:	{   long i0 = size_t(i)<size_t(nx-1) ? i+nx*(j+ny*k):nx*(1+j+ny*k)-2;	return abs(a[i0+1]-a[i0]);	}
mgl2_8.0.1_(mathgl)/C-include/datac.h://	{   long i0=i+nx*(j+ny*k);
mgl2_8.0.1_(mathgl)/C-include/datac.h:	mreal dvy(long i,long j=0,long k=0) const
mgl2_8.0.1_(mathgl)/C-include/datac.h:	{   long i0 = size_t(j)<size_t(ny-1) ? i+nx*(j+ny*k):i+nx*(ny*(k+1)-2);	return abs(a[i0+nx]-a[i0]);	}
mgl2_8.0.1_(mathgl)/C-include/datac.h://	{   long i0=i+nx*(j+ny*k);
mgl2_8.0.1_(mathgl)/C-include/datac.h:	mreal dvz(long i,long j=0,long k=0) const
mgl2_8.0.1_(mathgl)/C-include/datac.h:	{   long n=nx*ny, i0 = size_t(k)<size_t(nz-1) ? i+nx*(j+ny*k):i+nx*(j+ny*(nz-2));	return abs(a[i0+n]-a[i0]);	}
mgl2_8.0.1_(mathgl)/C-include/datac.h://	{   long i0=i+nx*(j+ny*k), n=nx*ny;
mgl2_8.0.1_(mathgl)/C-include/datac.h:/// Saves result of PDE solving for "Hamiltonian" ham with initial conditions ini along a curve ray (must have nx>=7 - x,y,z,px,py,pz,tau or nx=5 - x,y,px,py,tau)
mgl2_8.0.1_(mathgl)/C-include/datac.h:/// Saves result of PDE solving for "Hamiltonian" ham with initial conditions ini along a curve ray (must have nx>=7 - x,y,z,px,py,pz,tau or nx=5 - x,y,px,py,tau)
mgl2_8.0.1_(mathgl)/C-include/datac.h: * 'x', 'y', 'z' for solving along x-,y-,z-directions, or
mgl2_8.0.1_(mathgl)/C-include/datac.h: * 'h' for solving along hexagonal direction at x-y plain (need nx=ny),
mgl2_8.0.1_(mathgl)/C-include/datac.h:inline mglDataC mglSubDataC(const mglDataA &dat, long xx, long yy=-1, long zz=-1)
mgl2_8.0.1_(mathgl)/C-include/mgl_cf.h: *   License along with this program; if not, write to the                 *
mgl2_8.0.1_(mathgl)/C-include/data_cf.h: *   License along with this program; if not, write to the                 *
mgl2_8.0.1_(mathgl)/C-include/data_cf.h:HMDT MGL_EXPORT mgl_create_data_size(long nx, long ny, long nz);
mgl2_8.0.1_(mathgl)/C-include/data_cf.h:void MGL_EXPORT mgl_data_rearrange(HMDT dat, long mx,long my,long mz);
mgl2_8.0.1_(mathgl)/C-include/data_cf.h:void MGL_EXPORT mgl_data_link(HMDT dat, mreal *A,long mx,long my,long mz);
mgl2_8.0.1_(mathgl)/C-include/data_cf.h:void MGL_EXPORT mgl_data_set_float(HMDT dat, const float *A,long mx,long my,long mz);
mgl2_8.0.1_(mathgl)/C-include/data_cf.h:void MGL_EXPORT mgl_data_set_double(HMDT dat, const double *A,long mx,long my,long mz);
mgl2_8.0.1_(mathgl)/C-include/data_cf.h:void MGL_EXPORT mgl_data_set_float2(HMDT d, float const * const *A,long N1,long N2);
mgl2_8.0.1_(mathgl)/C-include/data_cf.h:void MGL_EXPORT mgl_data_set_double2(HMDT d, double const * const *A,long N1,long N2);
mgl2_8.0.1_(mathgl)/C-include/data_cf.h:void MGL_EXPORT mgl_data_set_float3(HMDT d, float const * const * const *A,long N1,long N2,long N3);
mgl2_8.0.1_(mathgl)/C-include/data_cf.h:void MGL_EXPORT mgl_data_set_double3(HMDT d, double const * const * const *A,long N1,long N2,long N3);
mgl2_8.0.1_(mathgl)/C-include/data_cf.h:void MGL_EXPORT mgl_data_set_value(HMDT dat, mreal v, long i, long j, long k);
mgl2_8.0.1_(mathgl)/C-include/data_cf.h:mreal MGL_EXPORT mgl_data_get_value(HCDT dat, long i, long j, long k);
mgl2_8.0.1_(mathgl)/C-include/data_cf.h:void MGL_EXPORT mgl_data_set_values(HMDT dat, const char *val, long nx, long ny, long nz);
mgl2_8.0.1_(mathgl)/C-include/data_cf.h:int MGL_EXPORT mgl_data_read_mat(HMDT dat, const char *fname, long dim);
mgl2_8.0.1_(mathgl)/C-include/data_cf.h:int MGL_EXPORT mgl_data_read_dim(HMDT dat, const char *fname,long mx,long my,long mz);
mgl2_8.0.1_(mathgl)/C-include/data_cf.h:/// Read data from binary file of type: 0 - double, 1 - float, 2 - long double, 3 - long int, 4 - int, 5 - short int, 6 - char.
mgl2_8.0.1_(mathgl)/C-include/data_cf.h:int MGL_EXPORT mgl_data_read_wfm(HMDT d,const char *fname, long num, long step, long start);
mgl2_8.0.1_(mathgl)/C-include/data_cf.h:int MGL_EXPORT mgl_data_read_wfm_(uintptr_t *d, const char *fname, long *num, long *step, long *start,int l);
mgl2_8.0.1_(mathgl)/C-include/data_cf.h:void MGL_EXPORT mgl_data_create(HMDT dat, long nx,long ny,long nz);
mgl2_8.0.1_(mathgl)/C-include/data_cf.h:void MGL_EXPORT mgl_data_norm(HMDT dat, mreal v1,mreal v2,int sym,long dim);
mgl2_8.0.1_(mathgl)/C-include/data_cf.h:void MGL_EXPORT mgl_data_norm_slice(HMDT dat, mreal v1,mreal v2,char dir,long keep_en,long sym);
mgl2_8.0.1_(mathgl)/C-include/data_cf.h:/// Keep the data sign/value along line i and j in given direction. 
mgl2_8.0.1_(mathgl)/C-include/data_cf.h:void MGL_EXPORT mgl_data_keep(HMDT dat, const char *how, long i, long j);
mgl2_8.0.1_(mathgl)/C-include/data_cf.h:void MGL_EXPORT mgl_data_keep_(uintptr_t *d, const char *how, long *i, long *j, int);
mgl2_8.0.1_(mathgl)/C-include/data_cf.h:HMDT MGL_EXPORT mgl_data_subdata(HCDT dat, long xx,long yy,long zz);
mgl2_8.0.1_(mathgl)/C-include/data_cf.h:/// Get data from sections ids, separated by value val along specified direction.
mgl2_8.0.1_(mathgl)/C-include/data_cf.h:/// Get data from section id, separated by value val along specified direction.
mgl2_8.0.1_(mathgl)/C-include/data_cf.h:HMDT MGL_EXPORT mgl_data_section_val(HCDT dat, long id, char dir, mreal val);
mgl2_8.0.1_(mathgl)/C-include/data_cf.h:HMDT MGL_EXPORT mgl_formula_calc(const char *str, long n, ...);
mgl2_8.0.1_(mathgl)/C-include/data_cf.h:void MGL_EXPORT mgl_data_refill_gs(HMDT dat, HCDT xdat, HCDT vdat, mreal x1, mreal x2, long sl);
mgl2_8.0.1_(mathgl)/C-include/data_cf.h:void MGL_EXPORT mgl_data_refill_gs_(uintptr_t *dat, uintptr_t *xdat, uintptr_t *vdat, mreal *x1, mreal *x2, long *sl);
mgl2_8.0.1_(mathgl)/C-include/data_cf.h:void MGL_EXPORT mgl_data_refill_x(HMDT dat, HCDT xdat, HCDT vdat, mreal x1, mreal x2, long sl);
mgl2_8.0.1_(mathgl)/C-include/data_cf.h:void MGL_EXPORT mgl_data_refill_x_(uintptr_t *dat, uintptr_t *xdat, uintptr_t *vdat, mreal *x1, mreal *x2, long *sl);
mgl2_8.0.1_(mathgl)/C-include/data_cf.h:void MGL_EXPORT mgl_data_refill_xy(HMDT dat, HCDT xdat, HCDT ydat, HCDT vdat, mreal x1, mreal x2, mreal y1, mreal y2, long sl);
mgl2_8.0.1_(mathgl)/C-include/data_cf.h:void MGL_EXPORT mgl_data_refill_xy_(uintptr_t *dat, uintptr_t *xdat, uintptr_t *ydat, uintptr_t *vdat, mreal *x1, mreal *x2, mreal *y1, mreal *y2, long *sl);
mgl2_8.0.1_(mathgl)/C-include/data_cf.h:void MGL_EXPORT mgl_data_refill_gr(HMGL gr, HMDT dat, HCDT xdat, HCDT ydat, HCDT zdat, HCDT vdat, long sl, const char *opt);
mgl2_8.0.1_(mathgl)/C-include/data_cf.h:void MGL_EXPORT mgl_data_refill_gr_(uintptr_t *gr, uintptr_t *dat, uintptr_t *xdat, uintptr_t *ydat, uintptr_t *zdat, uintptr_t *vdat, long *sl, const char *opt,int);
mgl2_8.0.1_(mathgl)/C-include/data_cf.h:void MGL_EXPORT mgl_data_put_val(HMDT dat, mreal val, long i, long j, long k);
mgl2_8.0.1_(mathgl)/C-include/data_cf.h:void MGL_EXPORT mgl_data_put_dat(HMDT dat, HCDT val, long i, long j, long k);
mgl2_8.0.1_(mathgl)/C-include/data_cf.h:void MGL_EXPORT mgl_data_modify(HMDT dat, const char *eq,long dim);
mgl2_8.0.1_(mathgl)/C-include/data_cf.h:void MGL_EXPORT mgl_data_squeeze(HMDT dat, long rx,long ry,long rz,long smooth);
mgl2_8.0.1_(mathgl)/C-include/data_cf.h:HMDT MGL_EXPORT mgl_data_ifs_2d(HCDT A, long n, long skip);
mgl2_8.0.1_(mathgl)/C-include/data_cf.h:uintptr_t MGL_EXPORT mgl_data_ifs_2d_(uintptr_t *A, long *n, long *skip);
mgl2_8.0.1_(mathgl)/C-include/data_cf.h:HMDT MGL_EXPORT mgl_data_ifs_3d(HCDT A, long n, long skip);
mgl2_8.0.1_(mathgl)/C-include/data_cf.h:uintptr_t MGL_EXPORT mgl_data_ifs_3d_(uintptr_t *A, long *n, long *skip);
mgl2_8.0.1_(mathgl)/C-include/data_cf.h:HMDT MGL_EXPORT mgl_data_ifs_file(const char *fname, const char *name, long n, long skip);
mgl2_8.0.1_(mathgl)/C-include/data_cf.h:uintptr_t mgl_data_ifs_file_(const char *fname, const char *name, long *n, long *skip,int l,int m);
mgl2_8.0.1_(mathgl)/C-include/data_cf.h:HMDT MGL_EXPORT mgl_data_flame_2d(HCDT A, HCDT F, long n, long skip);
mgl2_8.0.1_(mathgl)/C-include/data_cf.h:uintptr_t MGL_EXPORT mgl_data_flame_2d_(uintptr_t *A, uintptr_t *F, long *n, long *skip);
mgl2_8.0.1_(mathgl)/C-include/data_cf.h: * 'x', 'y', 'z' for solving along x-,y-,z-directions, or
mgl2_8.0.1_(mathgl)/C-include/data_cf.h: * 'h' for solving along hexagonal direction at x-y plain (need nx=ny),
mgl2_8.0.1_(mathgl)/C-include/data_cf.h:MGL_EXPORT mreal *mgl_data_value(HMDT dat, long i,long j,long k);
mgl2_8.0.1_(mathgl)/C-include/data_cf.h:long MGL_EXPORT mgl_data_get_nx(HCDT d);
mgl2_8.0.1_(mathgl)/C-include/data_cf.h:long MGL_EXPORT mgl_data_get_nx_(uintptr_t *d);
mgl2_8.0.1_(mathgl)/C-include/data_cf.h:long MGL_EXPORT mgl_data_get_ny(HCDT d);
mgl2_8.0.1_(mathgl)/C-include/data_cf.h:long MGL_EXPORT mgl_data_get_ny_(uintptr_t *d);
mgl2_8.0.1_(mathgl)/C-include/data_cf.h:long MGL_EXPORT mgl_data_get_nz(HCDT d);
mgl2_8.0.1_(mathgl)/C-include/data_cf.h:long MGL_EXPORT mgl_data_get_nz_(uintptr_t *d);
mgl2_8.0.1_(mathgl)/C-include/data_cf.h:void MGL_EXPORT mgl_data_extend(HMDT dat, long n1, long n2);
mgl2_8.0.1_(mathgl)/C-include/data_cf.h:void MGL_EXPORT mgl_data_insert(HMDT dat, char dir, long at, long num);
mgl2_8.0.1_(mathgl)/C-include/data_cf.h:void MGL_EXPORT mgl_data_delete(HMDT dat, char dir, long at, long num);
mgl2_8.0.1_(mathgl)/C-include/data_cf.h:/// Differentiate the parametrically specified data along direction v1 with v2,v3=const (v3 can be NULL)
mgl2_8.0.1_(mathgl)/C-include/data_cf.h:/// Roll data along direction dir by num slices
mgl2_8.0.1_(mathgl)/C-include/data_cf.h:void MGL_EXPORT mgl_data_roll(HMDT dat, char dir, long num);
mgl2_8.0.1_(mathgl)/C-include/data_cf.h:void MGL_EXPORT mgl_data_sort(HMDT dat, long idx, long idy);
mgl2_8.0.1_(mathgl)/C-include/data_cf.h:void MGL_EXPORT mgl_data_dilate(HMDT dat, mreal val, long step);
mgl2_8.0.1_(mathgl)/C-include/data_cf.h:void MGL_EXPORT mgl_data_erode(HMDT dat, mreal val, long step);
mgl2_8.0.1_(mathgl)/C-include/data_cf.h:MGL_EXPORT void *mgl_fft_alloc(long n, void **space, long nthr);
mgl2_8.0.1_(mathgl)/C-include/data_cf.h:MGL_EXPORT void *mgl_fft_alloc_thr(long n);
mgl2_8.0.1_(mathgl)/C-include/data_cf.h:void MGL_EXPORT mgl_fft_free(void *wt, void **ws, long nthr);
mgl2_8.0.1_(mathgl)/C-include/data_cf.h:void MGL_EXPORT mgl_fft(double *x, long s, long n, const void *wt, void *ws, int inv);
mgl2_8.0.1_(mathgl)/C-include/data_cf.h:mreal MGL_EXPORT mgl_data_solve_1d(HCDT dat, mreal val, int spl, long i0);
mgl2_8.0.1_(mathgl)/C-include/data_cf.h:HMDT MGL_EXPORT mgl_data_resize(HCDT dat, long mx,long my,long mz);
mgl2_8.0.1_(mathgl)/C-include/data_cf.h:HMDT MGL_EXPORT mgl_data_resize_box(HCDT dat, long mx,long my,long mz,mreal x1,mreal x2,mreal y1,mreal y2,mreal z1,mreal z2);
mgl2_8.0.1_(mathgl)/C-include/data_cf.h:HMDT MGL_EXPORT mgl_data_hist(HCDT dat, long n, mreal v1, mreal v2, long nsub);
mgl2_8.0.1_(mathgl)/C-include/data_cf.h:HMDT MGL_EXPORT mgl_data_hist_w(HCDT dat, HCDT weight, long n, mreal v1, mreal v2, long nsub);
mgl2_8.0.1_(mathgl)/C-include/data_cf.h:/// Get momentum (1D-array) of data along direction 'dir'. String looks like "x1" for median in x-direction, "x2" for width in x-dir and so on.
mgl2_8.0.1_(mathgl)/C-include/data_cf.h:void MGL_EXPORT mgl_data_crop(HMDT dat, long n1, long n2, char dir);
mgl2_8.0.1_(mathgl)/C-include/data_cf.h:void MGL_EXPORT mgl_data_clean(HMDT dat, long id);
mgl2_8.0.1_(mathgl)/C-include/data_cf.h:HMDT MGL_EXPORT mgl_data_stfa(HCDT re, HCDT im, long dn, char dir);
mgl2_8.0.1_(mathgl)/C-include/data_cf.h:mreal MGL_EXPORT mgl_rnd_integer(long lo, long hi);
mgl2_8.0.1_(mathgl)/C-include/data_cf.h:long MGL_EXPORT mgl_rnd_binomial(long trials, mreal p);
mgl2_8.0.1_(mathgl)/C-include/data_cf.h:long MGL_EXPORT mgl_rnd_discrete(HCDT A);
mgl2_8.0.1_(mathgl)/C-include/data_cf.h:void MGL_EXPORT mgl_data_rnd_integer(HMDT d, long lo, long hi);
mgl2_8.0.1_(mathgl)/C-include/data_cf.h:void MGL_EXPORT mgl_data_rnd_binomial(HMDT d, long trials, mreal p);
mgl2_8.0.1_(mathgl)/C-include/data_cf.h:/// Fills data by fractional brownian motions along x-direction
mgl2_8.0.1_(mathgl)/C-include/prim.h: *   License along with this program; if not, write to the                 *
mgl2_8.0.1_(mathgl)/C-include/prim.h:/** Parameter \a shift set the degree of drop oblongness: ‘0’ is sphere, ‘1’ is maximally oblongness drop. Parameter \a ap set relative width of the drop (this is analogue of “ellipticity” for the sphere).*/
mgl2_8.0.1_(mathgl)/C-include/prim.h:/// Print text in position {x,y,z} along direction {dx,dy,dz} with specified font
mgl2_8.0.1_(mathgl)/C-include/prim.h:/// Draw user-defined symbol in position p along direction d
mgl2_8.0.1_(mathgl)/C-include/prim.h:/// Draw table for values val along given direction with row labels text at position {x,y}
mgl2_8.0.1_(mathgl)/C-include/prim.h:/// Draws bitmap (logo) which is stretched along whole axis range
mgl2_8.0.1_(mathgl)/C-include/prim.h:void MGL_EXPORT mgl_logo(HMGL gr, long w, long h, const unsigned char *rgba, int smooth, const char *opt);
mgl2_8.0.1_(mathgl)/C-include/canvas.h: *   License along with this program; if not, write to the                 *
mgl2_8.0.1_(mathgl)/C-include/canvas.h:	virtual unsigned char **GetRGBLines(long &w, long &h, unsigned char *&f, bool alpha=false);
mgl2_8.0.1_(mathgl)/C-include/canvas.h:	inline void SetObjId(long id)	{	ObjId = id;	}
mgl2_8.0.1_(mathgl)/C-include/canvas.h:	inline int GetObjId(long xs,long ys) const
mgl2_8.0.1_(mathgl)/C-include/canvas.h:	{	long i=xs+Width*ys;	return (i>=0 && i<Width*Height)?OI[i]:-1;	}
mgl2_8.0.1_(mathgl)/C-include/canvas.h:	int GetSplId(long xs,long ys) const MGL_FUNC_PURE;
mgl2_8.0.1_(mathgl)/C-include/canvas.h:	virtual void DelFrame(long i);
mgl2_8.0.1_(mathgl)/C-include/canvas.h:	void GetFrame(long i);
mgl2_8.0.1_(mathgl)/C-include/canvas.h:	virtual void SetFrame(long i);
mgl2_8.0.1_(mathgl)/C-include/canvas.h:	void ShowFrame(long i);
mgl2_8.0.1_(mathgl)/C-include/canvas.h:	/// Draw table for values val along given direction with row labels text at given position
mgl2_8.0.1_(mathgl)/C-include/canvas.h:	void pnt_plot(long x,long y,mreal z,const unsigned char c[4], int obj_id);
mgl2_8.0.1_(mathgl)/C-include/canvas.h:	void pnt_fast(long x,long y,mreal z,const unsigned char c[4], int obj_id);
mgl2_8.0.1_(mathgl)/C-include/canvas.h:	inline uint32_t GetPntCol(long i) const	{	return pnt_col[i];	}
mgl2_8.0.1_(mathgl)/C-include/canvas.h:	inline uint32_t GetPrmCol(long i, bool sort=true) const	{	return GetColor(GetPrm(i, sort));	}
mgl2_8.0.1_(mathgl)/C-include/canvas.h:	long AddPairBnd(const mglPnt &q1, const mglPnt &q2);
mgl2_8.0.1_(mathgl)/C-include/canvas.h:	long PushDrwDat();
mgl2_8.0.1_(mathgl)/C-include/canvas.h:	void mark_plot(long p, char type, mreal size=1);
mgl2_8.0.1_(mathgl)/C-include/canvas.h:	void arrow_plot(long p1, long p2, char st);
mgl2_8.0.1_(mathgl)/C-include/canvas.h:	void line_plot(long p1, long p2);
mgl2_8.0.1_(mathgl)/C-include/canvas.h:	void trig_plot(long p1, long p2, long p3);
mgl2_8.0.1_(mathgl)/C-include/canvas.h:	void quad_plot(long p1, long p2, long p3, long p4);
mgl2_8.0.1_(mathgl)/C-include/canvas.h:	void Glyph(mreal x, mreal y, mreal f, int style, long icode, mreal col);
mgl2_8.0.1_(mathgl)/C-include/canvas.h:	void smbl_plot(long p1, char id, double size);
mgl2_8.0.1_(mathgl)/C-include/canvas.h:	mreal text_plot(long p,const wchar_t *text,const char *fnt,mreal size=-1,mreal sh=0,mreal  col=-('k'), bool rot=true);
mgl2_8.0.1_(mathgl)/C-include/canvas.h:	void arrow_draw(long n1, long n2, char st, float ll);
mgl2_8.0.1_(mathgl)/C-include/canvas.h:	void arrow_plot_3d(long n1, long n2, char st, float ll);
mgl2_8.0.1_(mathgl)/C-include/canvas.h:	void pxl_pntcol(long id, long n, const void *);
mgl2_8.0.1_(mathgl)/C-include/canvas.h:	void pxl_combine(long id, long n, const void *);
mgl2_8.0.1_(mathgl)/C-include/canvas.h:	void pxl_memcpy(long id, long n, const void *);
mgl2_8.0.1_(mathgl)/C-include/canvas.h:	void pxl_backgr(long id, long n, const void *);
mgl2_8.0.1_(mathgl)/C-include/canvas.h:	void pxl_primdr(long id, long n, const void *);
mgl2_8.0.1_(mathgl)/C-include/canvas.h:	void pxl_dotsdr(long id, long n, const void *);
mgl2_8.0.1_(mathgl)/C-include/canvas.h:	void pxl_primpx(long id, long n, const void *);
mgl2_8.0.1_(mathgl)/C-include/canvas.h:	void pxl_transform(long id, long n, const void *);
mgl2_8.0.1_(mathgl)/C-include/canvas.h:	void pxl_setz(long id, long n, const void *);
mgl2_8.0.1_(mathgl)/C-include/canvas.h:	void pxl_setz_adv(long id, long n, const void *);
mgl2_8.0.1_(mathgl)/C-include/canvas.h:	void pxl_other(long id, long n, const void *p);
mgl2_8.0.1_(mathgl)/C-include/canvas.h:	long forg;			///< original point (for directions)
mgl2_8.0.1_(mathgl)/C-include/canvas.h:	char GetLabelPos(mreal c, long kk, mglAxis &aa);
mgl2_8.0.1_(mathgl)/C-include/canvas.h:	long ProjScale(int nface, long p, bool text=false);
mgl2_8.0.1_(mathgl)/C-include/canvas.h:	long setPp(mglPnt &q, const mglPoint &p);
mgl2_8.0.1_(mathgl)/C-include/canvas.h:	void mark_pix(long i,long j,const mglPnt &p, char type, mreal size, mglDrawReg *d);
mgl2_8.0.1_(mathgl)/C-include/canvas.h:	void arrow_pix(long i,long j,const mglPnt &p1, const mglPnt &p2, char st, mreal size, const mglDrawReg *d);
mgl2_8.0.1_(mathgl)/C-include/canvas.h:	void line_pix(long i,long j,const mglPnt &p1, const mglPnt &p2, const mglDrawReg *d);
mgl2_8.0.1_(mathgl)/C-include/canvas.h:	void trig_pix(long i,long j,const mglPnt &p1, const mglPnt &p2, const mglPnt &p3, bool anorm, const mglDrawReg *d);
mgl2_8.0.1_(mathgl)/C-include/canvas.h:	void quad_pix(long i,long j,const mglPnt &p1, const mglPnt &p2, const mglPnt &p3, const mglPnt &p4, const mglDrawReg *d);
mgl2_8.0.1_(mathgl)/C-include/canvas.h:	void glyph_pix(long i,long j,const mglPrim &P, mglDrawReg *d);
mgl2_8.0.1_(mathgl)/C-include/canvas.h:	void pnt_pix(long i,long j,const mglPnt &p, const mglDrawReg *d);
mgl2_8.0.1_(mathgl)/C-include/canvas.h:	void glyph_fpix(long i,long j,const mglMatrix *M, const mglPnt &p, mreal f, const mglGlyph &g, const mglDrawReg *d);
mgl2_8.0.1_(mathgl)/C-include/canvas.h:	void glyph_wpix(long i,long j,const mglMatrix *M, const mglPnt &p, mreal f, const mglGlyph &g, const mglDrawReg *d);
mgl2_8.0.1_(mathgl)/C-include/canvas.h:	void glyph_lpix(long i,long j,const mglMatrix *M, const mglPnt &p, mreal f, bool solid, const mglDrawReg *d);
mgl2_8.0.1_(mathgl)/C-include/canvas.h:	void (mglCanvas::*f)(long i, long n, const void *);
mgl2_8.0.1_(mathgl)/C-include/canvas.h:	long n;	// total number of iteration
mgl2_8.0.1_(mathgl)/C-include/canvas.h:void mglStartThread(void (mglCanvas::*func)(long i, long n), mglCanvas *gr, long n);
mgl2_8.0.1_(mathgl)/C-include/abstract.h: *   License along with this program; if not, write to the                 *
mgl2_8.0.1_(mathgl)/C-include/abstract.h:std::string MGL_EXPORT mgl_data_to_string(HCDT d, long ns);
mgl2_8.0.1_(mathgl)/C-include/abstract.h:std::string MGL_EXPORT mgl_datac_to_string(HCDT d, long ns);
mgl2_8.0.1_(mathgl)/C-include/abstract.h:void MGL_EXPORT mgl_srnd(long seed);
mgl2_8.0.1_(mathgl)/C-include/abstract.h:void MGL_EXPORT mgl_data_save(HCDT dat, const char *fname,long ns);
mgl2_8.0.1_(mathgl)/C-include/abstract.h:void MGL_EXPORT mgl_data_export(HCDT dat, const char *fname, const char *scheme, double v1, double v2, long ns);
mgl2_8.0.1_(mathgl)/C-include/abstract.h:void MGL_EXPORT mgl_int_save_hdf(long val,const char *fname,const char *data,int rewrite);
mgl2_8.0.1_(mathgl)/C-include/abstract.h:void MGL_EXPORT mgl_int_save_hdf_(long *val, const char *fname, const char *data, int *rewrite, int, int);
mgl2_8.0.1_(mathgl)/C-include/abstract.h:long MGL_EXPORT mgl_datas_hdf(const char *fname, char *buf, long size);
mgl2_8.0.1_(mathgl)/C-include/abstract.h:long MGL_EXPORT mgl_datas_hdf_(const char *fname, char *buf, int l, int size);
mgl2_8.0.1_(mathgl)/C-include/abstract.h:mreal MGL_EXPORT mgl_data_first(HCDT dat, const char *cond, long *i, long *j, long *k);
mgl2_8.0.1_(mathgl)/C-include/abstract.h:mreal MGL_EXPORT mgl_data_last(HCDT dat, const char *cond, long *i, long *j, long *k);
mgl2_8.0.1_(mathgl)/C-include/abstract.h:long MGL_EXPORT mgl_data_find(HCDT dat, const char *cond, char dir, long i, long j, long k);
mgl2_8.0.1_(mathgl)/C-include/abstract.h:mreal MGL_EXPORT mgl_data_max_int(HCDT dat, long *i, long *j, long *k);
mgl2_8.0.1_(mathgl)/C-include/abstract.h:mreal MGL_EXPORT mgl_data_min_int(HCDT dat, long *i, long *j, long *k);
mgl2_8.0.1_(mathgl)/C-include/abstract.h:/// Get first (last if from<0) maximum along direction dir, and save its orthogonal coordinates in p1, p2
mgl2_8.0.1_(mathgl)/C-include/abstract.h:long MGL_EXPORT mgl_data_max_first(HCDT d, char dir, long from, long *p1, long *p2);
mgl2_8.0.1_(mathgl)/C-include/abstract.h:long MGL_EXPORT mgl_data_max_first_(uintptr_t *d, const char *dir, long *from, long *p1, long *p2,int);
mgl2_8.0.1_(mathgl)/C-include/abstract.h:		for(long i = mglDataList.size()-1; i>=0; i--)
mgl2_8.0.1_(mathgl)/C-include/abstract.h:	virtual void set_v(mreal /*val*/, long /*i*/,long /*j*/=0,long /*k*/=0)	{}
mgl2_8.0.1_(mathgl)/C-include/abstract.h:	virtual mreal v(long i,long j=0,long k=0) const = 0;
mgl2_8.0.1_(mathgl)/C-include/abstract.h:	virtual mreal vthr(long i) const
mgl2_8.0.1_(mathgl)/C-include/abstract.h:	virtual dual vc(long i,long j=0,long k=0) const	{	return v(i,j,k);	}
mgl2_8.0.1_(mathgl)/C-include/abstract.h:	virtual dual vcthr(long i) const	{	return vthr(i);	}
mgl2_8.0.1_(mathgl)/C-include/abstract.h:	virtual long GetNx() const = 0;
mgl2_8.0.1_(mathgl)/C-include/abstract.h:	virtual long GetNy() const = 0;
mgl2_8.0.1_(mathgl)/C-include/abstract.h:	virtual long GetNz() const = 0;
mgl2_8.0.1_(mathgl)/C-include/abstract.h:	inline long GetNN() const {	return GetNx()*GetNy()*GetNz();	}
mgl2_8.0.1_(mathgl)/C-include/abstract.h:	virtual mreal dvx(long i,long j=0,long k=0) const = 0;
mgl2_8.0.1_(mathgl)/C-include/abstract.h:	virtual mreal dvy(long i,long j=0,long k=0) const = 0;
mgl2_8.0.1_(mathgl)/C-include/abstract.h:	virtual mreal dvz(long i,long j=0,long k=0) const = 0;
mgl2_8.0.1_(mathgl)/C-include/abstract.h:	virtual void Save(const char *fname,long ns=-1) const
mgl2_8.0.1_(mathgl)/C-include/abstract.h:	virtual std::string Get(long ns=-1) const
mgl2_8.0.1_(mathgl)/C-include/abstract.h:	inline void Export(const char *fname,const char *scheme,mreal v1=0,mreal v2=0,long ns=-1) const
mgl2_8.0.1_(mathgl)/C-include/abstract.h:	inline static int DatasHDF(const char *fname, char *buf, long size)
mgl2_8.0.1_(mathgl)/C-include/abstract.h:	inline mreal Maximal(long &i,long &j,long &k) const
mgl2_8.0.1_(mathgl)/C-include/abstract.h:	inline mreal Minimal(long &i,long &j,long &k) const
mgl2_8.0.1_(mathgl)/C-include/abstract.h:	/// Get first (last if from<0) maximum along direction dir, and save its orthogonal coordinates in p1, p2
mgl2_8.0.1_(mathgl)/C-include/abstract.h:	inline long Maximal(char dir, long from, long &p1, long &p2) const
mgl2_8.0.1_(mathgl)/C-include/abstract.h:	inline long Maximal(char dir, long from) const
mgl2_8.0.1_(mathgl)/C-include/abstract.h:	inline mreal Find(const char *cond, long &i, long &j, long &k) const
mgl2_8.0.1_(mathgl)/C-include/abstract.h:	inline mreal Last(const char *cond, long &i, long &j, long &k) const
mgl2_8.0.1_(mathgl)/C-include/abstract.h:	inline long Find(const char *cond, char dir, long i=0, long j=0, long k=0) const
mgl2_8.0.1_(mathgl)/C-include/wnd.h: *   License along with this program; if not, write to the                 *
mgl2_8.0.1_(mathgl)/C-include/window.h: *   License along with this program; if not, write to the                 *
mgl2_8.0.1_(mathgl)/C-include/datac_cf.h: *   License along with this program; if not, write to the                 *
mgl2_8.0.1_(mathgl)/C-include/datac_cf.h:HADT MGL_EXPORT mgl_create_datac_size(long nx, long ny, long nz);
mgl2_8.0.1_(mathgl)/C-include/datac_cf.h:void MGL_EXPORT mgl_datac_rearrange(HADT dat, long mx,long my,long mz);
mgl2_8.0.1_(mathgl)/C-include/datac_cf.h:void MGL_EXPORT mgl_datac_link(HADT dat, mdual *A,long mx,long my,long mz);
mgl2_8.0.1_(mathgl)/C-include/datac_cf.h:void MGL_EXPORT mgl_datac_set_float(HADT dat, const float *A,long mx,long my,long mz);
mgl2_8.0.1_(mathgl)/C-include/datac_cf.h:void MGL_EXPORT mgl_datac_set_double(HADT dat, const double *A,long mx,long my,long mz);
mgl2_8.0.1_(mathgl)/C-include/datac_cf.h:void MGL_EXPORT mgl_datac_set_complex(HADT dat, const mdual *A,long mx,long my,long mz);
mgl2_8.0.1_(mathgl)/C-include/datac_cf.h:void MGL_EXPORT mgl_datac_set_value(HADT dat, mdual v, long i, long j, long k);
mgl2_8.0.1_(mathgl)/C-include/datac_cf.h:cmdual MGL_EXPORT mgl_datac_get_value(HCDT dat, long i, long j, long k);
mgl2_8.0.1_(mathgl)/C-include/datac_cf.h:void MGL_EXPORT mgl_datac_set_values(HADT dat, const char *val, long nx, long ny, long nz);
mgl2_8.0.1_(mathgl)/C-include/datac_cf.h: * 'x', 'y', 'z' for solving along x-,y-,z-directions, or
mgl2_8.0.1_(mathgl)/C-include/datac_cf.h: * 'h' for solving along hexagonal direction at x-y plain (need nx=ny),
mgl2_8.0.1_(mathgl)/C-include/datac_cf.h:MGL_EXPORT mdual *mgl_datac_value(HADT dat, long i,long j,long k);
mgl2_8.0.1_(mathgl)/C-include/datac_cf.h:int MGL_EXPORT mgl_datac_read_mat(HADT dat, const char *fname, long dim);
mgl2_8.0.1_(mathgl)/C-include/datac_cf.h:int MGL_EXPORT mgl_datac_read_dim(HADT dat, const char *fname,long mx,long my,long mz);
mgl2_8.0.1_(mathgl)/C-include/datac_cf.h:void MGL_EXPORT mgl_datac_save(HCDT dat, const char *fname,long ns);
mgl2_8.0.1_(mathgl)/C-include/datac_cf.h:void MGL_EXPORT mgl_datac_create(HADT dat, long nx,long ny,long nz);
mgl2_8.0.1_(mathgl)/C-include/datac_cf.h:HADT MGL_EXPORT mgl_datac_subdata(HCDT dat, long xx,long yy,long zz);
mgl2_8.0.1_(mathgl)/C-include/datac_cf.h:HADT MGL_EXPORT mgl_datac_resize(HCDT dat, long mx,long my,long mz);
mgl2_8.0.1_(mathgl)/C-include/datac_cf.h:HADT MGL_EXPORT mgl_datac_resize_box(HCDT dat, long mx,long my,long mz,mreal x1,mreal x2,mreal y1,mreal y2,mreal z1,mreal z2);
mgl2_8.0.1_(mathgl)/C-include/datac_cf.h:/// Get momentum (1D-array) of data along direction 'dir'. String looks like "x1" for median in x-direction, "x2" for width in x-dir and so on.
mgl2_8.0.1_(mathgl)/C-include/datac_cf.h:/// Get data from sections ids, separated by value val along specified direction.
mgl2_8.0.1_(mathgl)/C-include/datac_cf.h:/// Get data from section id, separated by value val along specified direction.
mgl2_8.0.1_(mathgl)/C-include/datac_cf.h:HADT MGL_EXPORT mgl_datac_section_val(HCDT dat, long id, char dir, mreal val);
mgl2_8.0.1_(mathgl)/C-include/datac_cf.h:HADT MGL_EXPORT mgl_formula_calc_c(const char *str, long n, ...);
mgl2_8.0.1_(mathgl)/C-include/datac_cf.h:void MGL_EXPORT mgl_datac_refill_gs(HADT dat, HCDT xdat, HCDT vdat, mreal x1, mreal x2, long sl);
mgl2_8.0.1_(mathgl)/C-include/datac_cf.h:void MGL_EXPORT mgl_datac_refill_gs_(uintptr_t *dat, uintptr_t *xdat, uintptr_t *vdat, mreal *x1, mreal *x2, long *sl);
mgl2_8.0.1_(mathgl)/C-include/datac_cf.h:void MGL_EXPORT mgl_datac_refill_x(HADT dat, HCDT xdat, HCDT vdat, mreal x1, mreal x2, long sl);
mgl2_8.0.1_(mathgl)/C-include/datac_cf.h:void MGL_EXPORT mgl_datac_refill_x_(uintptr_t *dat, uintptr_t *xdat, uintptr_t *vdat, mreal *x1, mreal *x2, long *sl);
mgl2_8.0.1_(mathgl)/C-include/datac_cf.h:void MGL_EXPORT mgl_datac_refill_xy(HADT dat, HCDT xdat, HCDT ydat, HCDT vdat, mreal x1, mreal x2, mreal y1, mreal y2, long sl);
mgl2_8.0.1_(mathgl)/C-include/datac_cf.h:void MGL_EXPORT mgl_datac_refill_xy_(uintptr_t *dat, uintptr_t *xdat, uintptr_t *ydat, uintptr_t *vdat, mreal *x1, mreal *x2, mreal *y1, mreal *y2, long *sl);
mgl2_8.0.1_(mathgl)/C-include/datac_cf.h:void MGL_EXPORT mgl_datac_refill_gr(HMGL gr, HADT dat, HCDT xdat, HCDT ydat, HCDT zdat, HCDT vdat, long sl, const char *opt);
mgl2_8.0.1_(mathgl)/C-include/datac_cf.h:void MGL_EXPORT mgl_datac_refill_gr_(uintptr_t *gr, uintptr_t *dat, uintptr_t *xdat, uintptr_t *ydat, uintptr_t *zdat, uintptr_t *vdat, long *sl, const char *opt,int);
mgl2_8.0.1_(mathgl)/C-include/datac_cf.h:void MGL_EXPORT mgl_datac_modify(HADT dat, const char *eq,long dim);
mgl2_8.0.1_(mathgl)/C-include/datac_cf.h:/// Keep the data phase/value along line i and j in given direction. 
mgl2_8.0.1_(mathgl)/C-include/datac_cf.h:void MGL_EXPORT mgl_datac_keep(HADT dat, const char *how, long i, long j);
mgl2_8.0.1_(mathgl)/C-include/datac_cf.h:void MGL_EXPORT mgl_datac_keep_(uintptr_t *d, const char *how, long *i, long *j, int);
mgl2_8.0.1_(mathgl)/C-include/datac_cf.h:void MGL_EXPORT mgl_datac_put_val(HADT dat, mdual val, long i, long j, long k);
mgl2_8.0.1_(mathgl)/C-include/datac_cf.h:void MGL_EXPORT mgl_datac_put_dat(HADT dat, HCDT val, long i, long j, long k);
mgl2_8.0.1_(mathgl)/C-include/datac_cf.h:void MGL_EXPORT mgl_datac_squeeze(HADT dat, long rx,long ry,long rz,long smooth);
mgl2_8.0.1_(mathgl)/C-include/datac_cf.h:void MGL_EXPORT mgl_datac_extend(HADT dat, long n1, long n2);
mgl2_8.0.1_(mathgl)/C-include/datac_cf.h:void MGL_EXPORT mgl_datac_insert(HADT dat, char dir, long at, long num);
mgl2_8.0.1_(mathgl)/C-include/datac_cf.h:void MGL_EXPORT mgl_datac_delete(HADT dat, char dir, long at, long num);
mgl2_8.0.1_(mathgl)/C-include/datac_cf.h:/// Differentiate the parametrically specified data along direction v1 with v2,v3=const (v3 can be NULL)
mgl2_8.0.1_(mathgl)/C-include/datac_cf.h:/// Roll data along direction dir by num slices
mgl2_8.0.1_(mathgl)/C-include/datac_cf.h:void MGL_EXPORT mgl_datac_roll(HADT dat, char dir, long num);
mgl2_8.0.1_(mathgl)/C-include/datac_cf.h:void MGL_EXPORT mgl_datac_crop(HADT dat, long n1, long n2, char dir);
mgl2_8.0.1_(mathgl)/C-include/datac_cf.h: * ‘x‘,‘y‘,‘z‘ or ‘r‘  for directions or axial along x,
mgl2_8.0.1_(mathgl)/C-include/parser.h: *   License along with this program; if not, write to the                 *
mgl2_8.0.1_(mathgl)/C-include/parser.h:	int (*exec)(mglGraph *gr, long n, mglArg *a, const char *k, const char *opt);
mgl2_8.0.1_(mathgl)/C-include/parser.h:	long pos;
mgl2_8.0.1_(mathgl)/C-include/parser.h:	mglFunc(long p, const wchar_t *f);
mgl2_8.0.1_(mathgl)/C-include/parser.h:	long pos;	///< position to return
mgl2_8.0.1_(mathgl)/C-include/parser.h:	long ind;	///< index in data array
mgl2_8.0.1_(mathgl)/C-include/parser.h:	long InUse;			///< Smart pointer (number of users)
mgl2_8.0.1_(mathgl)/C-include/parser.h:	inline int Parse(HMGL gr, const char *str, long pos=0)
mgl2_8.0.1_(mathgl)/C-include/parser.h:	int Parse(mglGraph *gr, const char *str, long pos=0);
mgl2_8.0.1_(mathgl)/C-include/parser.h:	inline int Parse(HMGL gr, const wchar_t *str, long pos=0)
mgl2_8.0.1_(mathgl)/C-include/parser.h:	int Parse(mglGraph *gr, std::wstring str, long pos=0);
mgl2_8.0.1_(mathgl)/C-include/parser.h:	long IsFunc(const wchar_t *name, int *narg=0);
mgl2_8.0.1_(mathgl)/C-include/parser.h:	int TestCond(long m, const mglArg &a0, mglArg &a1, bool &cond)
mgl2_8.0.1_(mathgl)/C-include/parser.h://	long parlen;		///< Length of parameter strings
mgl2_8.0.1_(mathgl)/C-include/parser.h:	int Exec(mglGraph *gr, const wchar_t *com, long n, mglArg *a, const std::wstring &var, const wchar_t *opt);
mgl2_8.0.1_(mathgl)/C-include/parser.h:	int PreExec(mglGraph *gr, long n, std::wstring *arg, mglArg *a);
mgl2_8.0.1_(mathgl)/C-include/parser.h:	int FlowExec(mglGraph *gr, const std::wstring &com, long n, mglArg *a);
mgl2_8.0.1_(mathgl)/C-include/cont.h: *   License along with this program; if not, write to the                 *
mgl2_8.0.1_(mathgl)/C-include/cont.h:/// Print text along the curve in parametric form {x,y,z}
mgl2_8.0.1_(mathgl)/C-include/cont.h:/// Print text along the curve in parametric form {x,y}
mgl2_8.0.1_(mathgl)/C-include/cont.h:/// Print text along the curve
mgl2_8.0.1_(mathgl)/C-include/cont.h:/// Draw contour lines at manual levels along slice for 3d data specified parametrically
mgl2_8.0.1_(mathgl)/C-include/cont.h:/// Draw contour lines at manual levels along slice for 3d data
mgl2_8.0.1_(mathgl)/C-include/cont.h:/// Draw contour lines along slice for 3d data specified parametrically
mgl2_8.0.1_(mathgl)/C-include/cont.h:/// Draw contour lines along slice for 3d data
mgl2_8.0.1_(mathgl)/C-include/cont.h:/// Draw solid contours at manual levels along slice for 3d data specified parametrically
mgl2_8.0.1_(mathgl)/C-include/cont.h:/// Draw solid contours at manual levels along slice for 3d data
mgl2_8.0.1_(mathgl)/C-include/cont.h:/// Draw solid contours along slice for 3d data specified parametrically
mgl2_8.0.1_(mathgl)/C-include/cont.h:/// Draw solid contours along slice for 3d data
mgl2_8.0.1_(mathgl)/C-include/Fl_MathGL.h: *   License along with this program; if not, write to the                 *
mgl2_8.0.1_(mathgl)/C-include/type.h: *   License along with this program; if not, write to the                 *
mgl2_8.0.1_(mathgl)/C-include/base.h: *   License along with this program; if not, write to the                 *
mgl2_8.0.1_(mathgl)/C-include/base.h:	long n1,n2,n3,n4;	///< coordinates of corners
mgl2_8.0.1_(mathgl)/C-include/base.h:	long n1,n2,n3,n4;	///< coordinates of corners {n1=x1,n2=x2,n3=y1,n4=y2}
mgl2_8.0.1_(mathgl)/C-include/base.h:	std::vector<long> p;	///< list of primitives (not filled!!!)
mgl2_8.0.1_(mathgl)/C-include/base.h://{	mglPnt p;	for(long i=0;i<10;i++)	p.dat[i] = a.dat[i]+b.dat[i];	p.sub=a.sub;	return p;	}
mgl2_8.0.1_(mathgl)/C-include/base.h://{	mglPnt p;	for(long i=0;i<10;i++)	p.dat[i] = a.dat[i]-b.dat[i];	p.sub=a.sub;	return p;	}
mgl2_8.0.1_(mathgl)/C-include/base.h://{	mglPnt p;	for(long i=0;i<10;i++)	p.dat[i] = a.dat[i]*b;	p.sub=a.sub;	return p;	}
mgl2_8.0.1_(mathgl)/C-include/base.h://{	mglPnt p;	for(long i=0;i<10;i++)	p.dat[i] = a.dat[i]*b;	p.sub=a.sub;	return p;	}
mgl2_8.0.1_(mathgl)/C-include/base.h:	long nt, nl;		///< number of triangles and lines
mgl2_8.0.1_(mathgl)/C-include/base.h:	mglGlyph(long Nt, long Nl):nt(0),nl(0),trig(0),line(0)	{	Create(Nt,Nl);	}
mgl2_8.0.1_(mathgl)/C-include/base.h:	void Create(long Nt, long Nl);	///< Allocate memory for given sizes
mgl2_8.0.1_(mathgl)/C-include/base.h:	long n;			///< Number of initial colors along u
mgl2_8.0.1_(mathgl)/C-include/base.h:	long InUse;			///< Smart pointer (number of users)
mgl2_8.0.1_(mathgl)/C-include/base.h:	inline long GetNumPal(long id) const	{	return Txt[labs(id)/256].n;	}
mgl2_8.0.1_(mathgl)/C-include/base.h:	inline void SetDrawReg(long nx=1, long ny=1, long m=0)	{	dr_x=nx;	dr_y=ny;	dr_p=m;	}
mgl2_8.0.1_(mathgl)/C-include/base.h:	inline long AddPnt(const mglPoint &p, mreal c=-1, const mglPoint &n=mglPoint(NAN), mreal a=-1, int scl=1)
mgl2_8.0.1_(mathgl)/C-include/base.h:	long AddPnt(const mglMatrix *M, const mglPoint &p, mreal c=-1, const mglPoint &n=mglPoint(NAN), mreal a=-1, int scl=1);
mgl2_8.0.1_(mathgl)/C-include/base.h:	inline bool AddPntQ(long id, const mglMatrix *M, const mglPoint &p, mreal c=-1, const mglPoint &n=mglPoint(NAN), mreal a=-1, int scl=1)
mgl2_8.0.1_(mathgl)/C-include/base.h:	inline bool AddPntQ(long id, const mglPoint &p, mreal c=-1, const mglPoint &n=mglPoint(NAN), mreal a=-1, int scl=1)
mgl2_8.0.1_(mathgl)/C-include/base.h:	long AllocPnts(size_t num);
mgl2_8.0.1_(mathgl)/C-include/base.h:	long PushPnts(size_t num, const mglPnt *qq);
mgl2_8.0.1_(mathgl)/C-include/base.h:	long CopyNtoC(long k, mreal c);
mgl2_8.0.1_(mathgl)/C-include/base.h:	bool CopyNtoC(mglPnt &q, long k, mreal c);
mgl2_8.0.1_(mathgl)/C-include/base.h:	inline bool CopyNtoC(long id, long k, mreal c)
mgl2_8.0.1_(mathgl)/C-include/base.h:	long CopyProj(long from, const mglPoint &p, const mglPoint &n, short sub=0);
mgl2_8.0.1_(mathgl)/C-include/base.h:	bool CopyProj(mglPnt &q, long from, const mglPoint &p, const mglPoint &n, short sub=0);
mgl2_8.0.1_(mathgl)/C-include/base.h:	void CopyProj(long id, long from, const mglPoint &p, const mglPoint &n, short sub=0)
mgl2_8.0.1_(mathgl)/C-include/base.h:	void DisablePnt(long id)	{	Pnt[id].x = NAN;	}
mgl2_8.0.1_(mathgl)/C-include/base.h:	void SetRGBA(long k, const mglColor &c)
mgl2_8.0.1_(mathgl)/C-include/base.h:	virtual void Reserve(long n);	///< Allocate n-cells for Pnt and return current position
mgl2_8.0.1_(mathgl)/C-include/base.h:	long AddGlyph(int s, long j);
mgl2_8.0.1_(mathgl)/C-include/base.h:	long AddGlyph(unsigned char id);
mgl2_8.0.1_(mathgl)/C-include/base.h:	void AddActive(long k,int n=0);
mgl2_8.0.1_(mathgl)/C-include/base.h:	inline mglPoint GetPntP(long i) const
mgl2_8.0.1_(mathgl)/C-include/base.h:	inline mglPoint GetPntN(long i) const
mgl2_8.0.1_(mathgl)/C-include/base.h:	inline mglColor GetPntC(long i) const
mgl2_8.0.1_(mathgl)/C-include/base.h:	inline float GetClrC(long i) const	{	return Pnt[i].c;	}
mgl2_8.0.1_(mathgl)/C-include/base.h:	inline const mglGlyph &GetGlf(long i) const	{	return Glf[i];	}
mgl2_8.0.1_(mathgl)/C-include/base.h:	inline long GetGlfNum() const		{	return Glf.size();	}
mgl2_8.0.1_(mathgl)/C-include/base.h:	inline const mglPnt &GetPnt(long i) const	{	return Pnt[i];		}
mgl2_8.0.1_(mathgl)/C-include/base.h:	inline long GetPntNum() const		{	return Pnt.size();	}
mgl2_8.0.1_(mathgl)/C-include/base.h:	inline bool SamePnt(long i, long j) const
mgl2_8.0.1_(mathgl)/C-include/base.h://	inline mglPrim &GetPrm(long i)		{	return Prm[i];		}
mgl2_8.0.1_(mathgl)/C-include/base.h:	inline mglPrim &GetPrm(long i, bool sort=true)
mgl2_8.0.1_(mathgl)/C-include/base.h:	inline const mglPrim &GetPrm(long i, bool sort=true) const
mgl2_8.0.1_(mathgl)/C-include/base.h:	inline long GetPrmNum() const		{	return Prm.size();	}
mgl2_8.0.1_(mathgl)/C-include/base.h:	inline const mglText &GetPtx(long i) const	{	return Ptx[i];		}
mgl2_8.0.1_(mathgl)/C-include/base.h:	inline long GetPtxNum() const		{	return Ptx.size();	}
mgl2_8.0.1_(mathgl)/C-include/base.h:	inline const mglTexture &GetTxt(long i) const	{	return Txt[i];	}
mgl2_8.0.1_(mathgl)/C-include/base.h:	inline long GetTxtNum() const		{	return Txt.size();	}
mgl2_8.0.1_(mathgl)/C-include/base.h:	inline mreal GetC(long s,mreal z,bool scale = true) const
mgl2_8.0.1_(mathgl)/C-include/base.h:	char SetPenPal(const char *stl, long *id=0, bool pal=true);
mgl2_8.0.1_(mathgl)/C-include/base.h:	long AddTexture(const char *cols, int smooth=0);
mgl2_8.0.1_(mathgl)/C-include/base.h:	mreal NextColor(long &id);
mgl2_8.0.1_(mathgl)/C-include/base.h:	mreal NextColor(long id, long sh);
mgl2_8.0.1_(mathgl)/C-include/base.h:	virtual void mark_plot(long p, char type, mreal size=1)=0;
mgl2_8.0.1_(mathgl)/C-include/base.h:	virtual void arrow_plot(long p1, long p2, char st)=0;
mgl2_8.0.1_(mathgl)/C-include/base.h:	virtual void line_plot(long p1, long p2)=0;
mgl2_8.0.1_(mathgl)/C-include/base.h:	virtual void trig_plot(long p1, long p2, long p3)=0;
mgl2_8.0.1_(mathgl)/C-include/base.h:	virtual void quad_plot(long p1, long p2, long p3, long p4)=0;
mgl2_8.0.1_(mathgl)/C-include/base.h:	virtual void smbl_plot(long p1, char id, double size)=0;
mgl2_8.0.1_(mathgl)/C-include/base.h:	virtual void Glyph(mreal x, mreal y, mreal f, int style, long icode, mreal col)=0;
mgl2_8.0.1_(mathgl)/C-include/base.h:	virtual mreal text_plot(long p,const wchar_t *text,const char *fnt,mreal size=-1,mreal sh=0,mreal  col=-('k'),bool rot=true)=0;
mgl2_8.0.1_(mathgl)/C-include/base.h:	void vect_plot(long p1, long p2, mreal s=1);
mgl2_8.0.1_(mathgl)/C-include/base.h://	long numT;			///< Number of textures
mgl2_8.0.1_(mathgl)/C-include/base.h:	long CurrPal;		///< Current palette index
mgl2_8.0.1_(mathgl)/C-include/base.h:	long dr_x, dr_y, dr_p;	///< default drawing region for quality&4 mode
mgl2_8.0.1_(mathgl)/C-include/base.h:	long CSS;			///< Saved flags
mgl2_8.0.1_(mathgl)/C-include/fltk.h: *   License along with this program; if not, write to the                 *
mgl2_8.0.1_(mathgl)/C-include/surf.h: *   License along with this program; if not, write to the                 *
mgl2_8.0.1_(mathgl)/C-include/data.h: *   License along with this program; if not, write to the                 *
mgl2_8.0.1_(mathgl)/C-include/data.h:mreal MGL_EXPORT_PURE mglLinear(const mreal *a, long nx, long ny, long nz, mreal x, mreal y, mreal z);
mgl2_8.0.1_(mathgl)/C-include/data.h:mreal MGL_EXPORT mglSpline3(const mreal *a, long nx, long ny, long nz, mreal x, mreal y, mreal z,mreal *dx=0, mreal *dy=0, mreal *dz=0);
mgl2_8.0.1_(mathgl)/C-include/data.h:mreal MGL_EXPORT_PURE mglSpline3s(const mreal *a, long nx, long ny, long nz, mreal x, mreal y, mreal z);
mgl2_8.0.1_(mathgl)/C-include/data.h:	long nx;		///< number of points in 1st dimensions ('x' dimension)
mgl2_8.0.1_(mathgl)/C-include/data.h:	long ny;		///< number of points in 2nd dimensions ('y' dimension)
mgl2_8.0.1_(mathgl)/C-include/data.h:	long nz;		///< number of points in 3d dimensions ('z' dimension)
mgl2_8.0.1_(mathgl)/C-include/data.h:	mglData(long xx=1,long yy=1,long zz=1)	{	a=0;	Create(xx,yy,zz);	}
mgl2_8.0.1_(mathgl)/C-include/data.h:	inline mreal GetVal(long i, long j=0, long k=0) const
mgl2_8.0.1_(mathgl)/C-include/data.h:	inline void SetVal(mreal f, long i, long j=0, long k=0)
mgl2_8.0.1_(mathgl)/C-include/data.h:	long GetNx() const	{	return nx;	}
mgl2_8.0.1_(mathgl)/C-include/data.h:	long GetNy() const	{	return ny;	}
mgl2_8.0.1_(mathgl)/C-include/data.h:	long GetNz() const	{	return nz;	}
mgl2_8.0.1_(mathgl)/C-include/data.h:	inline void Link(mreal *A, long NX, long NY=1, long NZ=1)
mgl2_8.0.1_(mathgl)/C-include/data.h:	inline void Set(const float *A,long NX,long NY=1,long NZ=1)
mgl2_8.0.1_(mathgl)/C-include/data.h:	inline void Set(const double *A,long NX,long NY=1,long NZ=1)
mgl2_8.0.1_(mathgl)/C-include/data.h:	inline void Set(float const * const *A,long N1,long N2)
mgl2_8.0.1_(mathgl)/C-include/data.h:	inline void Set(double const * const *A,long N1,long N2)
mgl2_8.0.1_(mathgl)/C-include/data.h:	inline void Set(float const * const * const *A,long N1,long N2,long N3)
mgl2_8.0.1_(mathgl)/C-include/data.h:	inline void Set(double const * const * const *A,long N1,long N2,long N3)
mgl2_8.0.1_(mathgl)/C-include/data.h:	inline void Set(const char *str,long NX,long NY=1,long NZ=1)
mgl2_8.0.1_(mathgl)/C-include/data.h:	{	if(d.size()>0)	{	Create(d.size());	for(long i=0;i<nx;i++)	a[i] = d[i];	}
mgl2_8.0.1_(mathgl)/C-include/data.h:	inline void SetList(long n, ...)
mgl2_8.0.1_(mathgl)/C-include/data.h:		for(long i=0;i<n;i++)	a[i] = va_arg(vl,double);
mgl2_8.0.1_(mathgl)/C-include/data.h:	{	Create(d.n_elem);	for(long i=0;i<nx;i++)	a[i] = d[i];	}
mgl2_8.0.1_(mathgl)/C-include/data.h:	{	Create(d.n_rows,d.n_cols);	for(long i=0;i<nx*ny;i++)	a[i] = d[i];	}
mgl2_8.0.1_(mathgl)/C-include/data.h:	{	Create(d.n_rows,d.n_cols,d.n_slices);	for(long i=0;i<nx*ny*nz;i++)	a[i] = d[i];	}
mgl2_8.0.1_(mathgl)/C-include/data.h:	inline arma::mat arma_mat(long k=0) const { return arma::mat(a+k*nx*ny,ny,nx);  }
mgl2_8.0.1_(mathgl)/C-include/data.h:	inline void Create(long mx,long my=1,long mz=1)
mgl2_8.0.1_(mathgl)/C-include/data.h:	inline void Rearrange(long mx, long my=0, long mz=0)
mgl2_8.0.1_(mathgl)/C-include/data.h:	inline void Extend(long n1, long n2=0)
mgl2_8.0.1_(mathgl)/C-include/data.h:	inline void Squeeze(long rx,long ry=1,long rz=1,bool smooth=false)
mgl2_8.0.1_(mathgl)/C-include/data.h:	inline void Crop(long n1, long n2,char dir='x')
mgl2_8.0.1_(mathgl)/C-include/data.h:	inline void Insert(char dir, long at=0, long num=1)
mgl2_8.0.1_(mathgl)/C-include/data.h:	inline void Delete(char dir, long at=0, long num=1)
mgl2_8.0.1_(mathgl)/C-include/data.h:	inline void Clean(long clmn)
mgl2_8.0.1_(mathgl)/C-include/data.h:	inline void Modify(const char *eq,long dim=0)
mgl2_8.0.1_(mathgl)/C-include/data.h:	inline void RefillGS(const mglDataA &xdat, const mglDataA &vdat, mreal x1, mreal x2,long sl=-1)
mgl2_8.0.1_(mathgl)/C-include/data.h:	inline void Refill(const mglDataA &xdat, const mglDataA &vdat, mreal x1, mreal x2,long sl=-1)
mgl2_8.0.1_(mathgl)/C-include/data.h:	inline void Refill(const mglDataA &xdat, const mglDataA &vdat, mglPoint p1, mglPoint p2,long sl=-1)
mgl2_8.0.1_(mathgl)/C-include/data.h:	inline void Refill(const mglDataA &xdat, const mglDataA &ydat, const mglDataA &vdat, mglPoint p1, mglPoint p2,long sl=-1)
mgl2_8.0.1_(mathgl)/C-include/data.h:	inline void Refill(HMGL gr, const mglDataA &xdat, const mglDataA &vdat, long sl=-1, const char *opt="")
mgl2_8.0.1_(mathgl)/C-include/data.h:	inline void Refill(HMGL gr, const mglDataA &xdat, const mglDataA &ydat, const mglDataA &vdat, long sl=-1, const char *opt="")
mgl2_8.0.1_(mathgl)/C-include/data.h:	inline void Put(mreal val, long i=-1, long j=-1, long k=-1)
mgl2_8.0.1_(mathgl)/C-include/data.h:	inline void Put(const mglDataA &dat, long i=-1, long j=-1, long k=-1)
mgl2_8.0.1_(mathgl)/C-include/data.h:	inline void RndInteger(long lo, long hi)
mgl2_8.0.1_(mathgl)/C-include/data.h:	inline void RndBinomial(long trials, mreal p=0.5)
mgl2_8.0.1_(mathgl)/C-include/data.h:	/// Fills data by fractional brownian motions along x-direction
mgl2_8.0.1_(mathgl)/C-include/data.h:	inline bool Read(const char *fname,long mx,long my=1,long mz=1)
mgl2_8.0.1_(mathgl)/C-include/data.h:	inline bool ReadMat(const char *fname, long dim=2)
mgl2_8.0.1_(mathgl)/C-include/data.h:	/// Read data from binary file of type: 0 - double, 1 - float, 2 - long double, 3 - long int, 4 - int, 5 - short int, 6 - char.
mgl2_8.0.1_(mathgl)/C-include/data.h:	/// Get momentum (1D-array) of data along direction 'dir'. String looks like "x1" for median in x-direction, "x2" for width in x-dir and so on.
mgl2_8.0.1_(mathgl)/C-include/data.h:	inline mglData SubData(long xx,long yy=-1,long zz=-1) const
mgl2_8.0.1_(mathgl)/C-include/data.h:	/// Get data from sections ids, separated by value val along specified direction.
mgl2_8.0.1_(mathgl)/C-include/data.h:	inline mglData Section(long id, char dir='y', mreal val=NAN) const
mgl2_8.0.1_(mathgl)/C-include/data.h:	inline mglData Hist(long n,mreal v1=0,mreal v2=1, long nsub=0) const
mgl2_8.0.1_(mathgl)/C-include/data.h:	inline mglData Hist(const mglDataA &w, long n,mreal v1=0,mreal v2=1, long nsub=0) const
mgl2_8.0.1_(mathgl)/C-include/data.h:	inline mglData Resize(long mx,long my=0,long mz=0, mreal x1=0,mreal x2=1, mreal y1=0,mreal y2=1, mreal z1=0,mreal z2=1) const
mgl2_8.0.1_(mathgl)/C-include/data.h:	/// Differentiate the parametrically specified data along direction v1
mgl2_8.0.1_(mathgl)/C-include/data.h:	/// Differentiate the parametrically specified data along direction v1 with v2=const
mgl2_8.0.1_(mathgl)/C-include/data.h:	/// Differentiate the parametrically specified data along direction v1 with v2,v3=const
mgl2_8.0.1_(mathgl)/C-include/data.h:	/// Roll data along direction dir by num slices
mgl2_8.0.1_(mathgl)/C-include/data.h:	inline void Roll(char dir, long num)	{	mgl_data_roll(this,dir,num);	}
mgl2_8.0.1_(mathgl)/C-include/data.h:	inline void Sort(long idx, long idy=-1)	{	mgl_data_sort(this,idx,idy);	}
mgl2_8.0.1_(mathgl)/C-include/data.h:	inline void Dilate(mreal val=1, long step=1)
mgl2_8.0.1_(mathgl)/C-include/data.h:	inline void Erode(mreal val=1, long step=1)
mgl2_8.0.1_(mathgl)/C-include/data.h:	inline void Norm(mreal v1=0,mreal v2=1,bool sym=false,long dim=0)
mgl2_8.0.1_(mathgl)/C-include/data.h:	/// Keep the data sign/value along line i and j in given direction. 
mgl2_8.0.1_(mathgl)/C-include/data.h:	inline void Keep(const char *how, long i, long j=0)
mgl2_8.0.1_(mathgl)/C-include/data.h:	inline mreal Solve(mreal val, bool use_spline=true, long i0=0) const
mgl2_8.0.1_(mathgl)/C-include/data.h:	inline mreal operator[](long i) const	{	return a[i];	}
mgl2_8.0.1_(mathgl)/C-include/data.h:	inline mreal &operator[](long i)		{	return a[i];	}
mgl2_8.0.1_(mathgl)/C-include/data.h:	inline mglData operator()(long xx,long yy=-1,long zz=-1) const
mgl2_8.0.1_(mathgl)/C-include/data.h:	mreal v(long i,long j=0,long k=0) const	{	return a[i+nx*(j+ny*k)];	}
mgl2_8.0.1_(mathgl)/C-include/data.h:	void set_v(mreal val, long i,long j=0,long k=0)	{	a[i+nx*(j+ny*k)]=val;	}
mgl2_8.0.1_(mathgl)/C-include/data.h:	mreal v(long i,long j=0,long k=0) const	{	return mgl_data_get_value(this,i,j,k);	}
mgl2_8.0.1_(mathgl)/C-include/data.h:	void set_v(mreal val, long i,long j=0,long k=0)	{	mgl_data_set_value(this,val,i,j,k);	}
mgl2_8.0.1_(mathgl)/C-include/data.h:	mreal vthr(long i) const {	return a[i];	}
mgl2_8.0.1_(mathgl)/C-include/data.h:	mreal dvx(long i,long j=0,long k=0) const
mgl2_8.0.1_(mathgl)/C-include/data.h:	{   long i0 = size_t(i)<size_t(nx-1) ? i+nx*(j+ny*k):nx*(1+j+ny*k)-2;	return a[i0+1]-a[i0];	}
mgl2_8.0.1_(mathgl)/C-include/data.h://	{   long i0=i+nx*(j+ny*k);
mgl2_8.0.1_(mathgl)/C-include/data.h:	mreal dvy(long i,long j=0,long k=0) const
mgl2_8.0.1_(mathgl)/C-include/data.h:	{   long i0 = size_t(j)<size_t(ny-1) ? i+nx*(j+ny*k):i+nx*(ny*(k+1)-2);	return a[i0+nx]-a[i0];	}
mgl2_8.0.1_(mathgl)/C-include/data.h://	{   long i0=i+nx*(j+ny*k);
mgl2_8.0.1_(mathgl)/C-include/data.h:	mreal dvz(long i,long j=0,long k=0) const
mgl2_8.0.1_(mathgl)/C-include/data.h:	{   long n=nx*ny, i0 = size_t(k)<size_t(nz-1) ? i+nx*(j+ny*k):i+nx*(j+ny*(nz-2));	return a[i0+n]-a[i0];	}
mgl2_8.0.1_(mathgl)/C-include/data.h://	{   long i0=i+nx*(j+ny*k), n=nx*ny;
mgl2_8.0.1_(mathgl)/C-include/data.h:inline mglData mglSTFA(const mglDataA &re, const mglDataA &im, long dn, char dir='x')
mgl2_8.0.1_(mathgl)/C-include/data.h:/// Saves result of PDE solving for "Hamiltonian" ham with initial conditions ini along a curve ray (must have nx>=7 - x,y,z,px,py,pz,tau or nx=5 - x,y,px,py,tau)
mgl2_8.0.1_(mathgl)/C-include/data.h:/// Saves result of PDE solving for "Hamiltonian" ham with initial conditions ini along a curve ray (must have nx>=7 - x,y,z,px,py,pz,tau or nx=5 - x,y,px,py,tau)
mgl2_8.0.1_(mathgl)/C-include/data.h: * 'x', 'y', 'z' for solving along x-,y-,z-directions, or
mgl2_8.0.1_(mathgl)/C-include/data.h: * 'h' for solving along hexagonal direction at x-y plain (need nx=ny),
mgl2_8.0.1_(mathgl)/C-include/data.h:inline mglData mglIFS2d(const mglDataA &A, long n, long skip=20)
mgl2_8.0.1_(mathgl)/C-include/data.h:inline mglData mglIFS3d(const mglDataA &A, long n, long skip=20)
mgl2_8.0.1_(mathgl)/C-include/data.h:inline mglData mglIFSfile(const char *fname, const char *name, long n, long skip=20)
mgl2_8.0.1_(mathgl)/C-include/data.h:inline mglData mglFlame2d(const mglDataA &A, const mglDataA &F, long n, long skip=20)
mgl2_8.0.1_(mathgl)/C-include/data.h:inline mglData mglSubData(const mglDataA &dat, long xx, long yy=-1, long zz=-1)
mgl2_8.0.1_(mathgl)/C-include/data.h:	long nx;	///< number of points in 1st dimensions ('x' dimension)
mgl2_8.0.1_(mathgl)/C-include/data.h:	long ny;	///< number of points in 2nd dimensions ('y' dimension)
mgl2_8.0.1_(mathgl)/C-include/data.h:	long nz;	///< number of points in 3d dimensions ('z' dimension)
mgl2_8.0.1_(mathgl)/C-include/data.h:	mglDataV(long xx=1,long yy=1,long zz=1,mreal x1=0,mreal x2=mglNaN,char dir='x'):nx(xx),ny(yy),nz(zz)
mgl2_8.0.1_(mathgl)/C-include/data.h:	long GetNx() const	{	return nx;	}
mgl2_8.0.1_(mathgl)/C-include/data.h:	long GetNy() const	{	return ny;	}
mgl2_8.0.1_(mathgl)/C-include/data.h:	long GetNz() const	{	return nz;	}
mgl2_8.0.1_(mathgl)/C-include/data.h:	inline void Create(long mx,long my=1,long mz=1)
mgl2_8.0.1_(mathgl)/C-include/data.h:	mreal v(long i,long j=0,long k=0) const		{	return a0+di*i+dj*j+dk*k;	}
mgl2_8.0.1_(mathgl)/C-include/data.h:	mreal vthr(long ii) const
mgl2_8.0.1_(mathgl)/C-include/data.h:	{	long i=ii%nx, j=(ii/nx)%ny, k=ii/(nx*ny);	return a0+di*i+dj*j+dk*k;	}
mgl2_8.0.1_(mathgl)/C-include/data.h:	mreal dvx(long ,long =0,long =0) const	{	return di;	}
mgl2_8.0.1_(mathgl)/C-include/data.h:	mreal dvy(long ,long =0,long =0) const	{	return dj;	}
mgl2_8.0.1_(mathgl)/C-include/data.h:	mreal dvz(long ,long =0,long =0) const	{	return dk;	}
mgl2_8.0.1_(mathgl)/C-include/data.h:	long nx;	///< number of points in 1st dimensions ('x' dimension)
mgl2_8.0.1_(mathgl)/C-include/data.h:	long ny;	///< number of points in 2nd dimensions ('y' dimension)
mgl2_8.0.1_(mathgl)/C-include/data.h:	long nz;	///< number of points in 3d dimensions ('z' dimension)
mgl2_8.0.1_(mathgl)/C-include/data.h:	mglDataW(long xx=1,long yy=1,long zz=1,mreal dp=0,char dir='x'):nx(xx),ny(yy),nz(zz)
mgl2_8.0.1_(mathgl)/C-include/data.h:	long GetNx() const	{	return nx;	}
mgl2_8.0.1_(mathgl)/C-include/data.h:	long GetNy() const	{	return ny;	}
mgl2_8.0.1_(mathgl)/C-include/data.h:	long GetNz() const	{	return nz;	}
mgl2_8.0.1_(mathgl)/C-include/data.h:	inline void Create(long mx,long my=1,long mz=1)
mgl2_8.0.1_(mathgl)/C-include/data.h:	mreal v(long i,long j=0,long k=0) const
mgl2_8.0.1_(mathgl)/C-include/data.h:	mreal vthr(long ii) const
mgl2_8.0.1_(mathgl)/C-include/data.h:	{	long i=ii%nx, j=(ii/nx)%ny, k=ii/(nx*ny);
mgl2_8.0.1_(mathgl)/C-include/data.h:	mreal dvx(long ,long =0,long =0) const	{	return di;	}
mgl2_8.0.1_(mathgl)/C-include/data.h:	mreal dvy(long ,long =0,long =0) const	{	return dj;	}
mgl2_8.0.1_(mathgl)/C-include/data.h:	mreal dvz(long ,long =0,long =0) const	{	return dk;	}
mgl2_8.0.1_(mathgl)/C-include/data.h:	long nx;	///< number of points in 1st dimensions ('x' dimension)
mgl2_8.0.1_(mathgl)/C-include/data.h:	long ny;	///< number of points in 2nd dimensions ('y' dimension)
mgl2_8.0.1_(mathgl)/C-include/data.h:	long nz;	///< number of points in 3d dimensions ('z' dimension)
mgl2_8.0.1_(mathgl)/C-include/data.h:	mglDataF(long xx=1,long yy=1,long zz=1):nx(xx),ny(yy),nz(zz), dfunc(0),par(0)
mgl2_8.0.1_(mathgl)/C-include/data.h:	long GetNx() const	{	return nx;	}
mgl2_8.0.1_(mathgl)/C-include/data.h:	long GetNy() const	{	return ny;	}
mgl2_8.0.1_(mathgl)/C-include/data.h:	long GetNz() const	{	return nz;	}
mgl2_8.0.1_(mathgl)/C-include/data.h:	inline void Create(long mx,long my=1,long mz=1)	{	nx=mx;	ny=my;	nz=mz;	setD();	}
mgl2_8.0.1_(mathgl)/C-include/data.h:	mreal v(long i,long j=0,long k=0) const
mgl2_8.0.1_(mathgl)/C-include/data.h:	mreal vthr(long i) const
mgl2_8.0.1_(mathgl)/C-include/data.h:	mreal dvx(long i,long j=0,long k=0) const
mgl2_8.0.1_(mathgl)/C-include/data.h:	mreal dvy(long i,long j=0,long k=0) const
mgl2_8.0.1_(mathgl)/C-include/data.h:	mreal dvz(long i,long j=0,long k=0) const
mgl2_8.0.1_(mathgl)/C-include/data.h:	long ind;
mgl2_8.0.1_(mathgl)/C-include/data.h:	mglDataT(const mglDataA &d, long col=0) : dat(d), ind(col)	{}
mgl2_8.0.1_(mathgl)/C-include/data.h:	mglDataT(HCDT d, long col=0) : dat(*d), ind(col)	{}
mgl2_8.0.1_(mathgl)/C-include/data.h:	long GetNx() const	{	return dat.GetNy();	}
mgl2_8.0.1_(mathgl)/C-include/data.h:	long GetNy() const	{	return dat.GetNz();	}
mgl2_8.0.1_(mathgl)/C-include/data.h:	long GetNz() const	{	return 1;	}
mgl2_8.0.1_(mathgl)/C-include/data.h:	inline void SetInd(long i, const wchar_t *name)
mgl2_8.0.1_(mathgl)/C-include/data.h:	inline void SetInd(long i, wchar_t name)
mgl2_8.0.1_(mathgl)/C-include/data.h:	mreal v(long i,long j=0,long =0) const
mgl2_8.0.1_(mathgl)/C-include/data.h:	mreal vthr(long i) const
mgl2_8.0.1_(mathgl)/C-include/data.h:	mreal dvx(long i,long j=0,long =0) const
mgl2_8.0.1_(mathgl)/C-include/data.h:	mreal dvy(long i,long j=0,long =0) const
mgl2_8.0.1_(mathgl)/C-include/data.h:	mreal dvz(long ,long =0,long =0) const
mgl2_8.0.1_(mathgl)/C-include/data.h:	long ind;
mgl2_8.0.1_(mathgl)/C-include/data.h:	mglDataR(const mglDataA &d, long row=0) : dat(d), ind(row)	{}
mgl2_8.0.1_(mathgl)/C-include/data.h:	mglDataR(HCDT d, long row=0) : dat(*d), ind(row)	{}
mgl2_8.0.1_(mathgl)/C-include/data.h:	long GetNx() const	{	return dat.GetNx();	}
mgl2_8.0.1_(mathgl)/C-include/data.h:	long GetNy() const	{	return 1;	}
mgl2_8.0.1_(mathgl)/C-include/data.h:	long GetNz() const	{	return 1;	}
mgl2_8.0.1_(mathgl)/C-include/data.h:	inline void SetInd(long i, const wchar_t *name)
mgl2_8.0.1_(mathgl)/C-include/data.h:	inline void SetInd(long i, wchar_t name)
mgl2_8.0.1_(mathgl)/C-include/data.h:	mreal v(long i,long =0,long =0) const
mgl2_8.0.1_(mathgl)/C-include/data.h:	mreal vthr(long i) const
mgl2_8.0.1_(mathgl)/C-include/data.h:	mreal dvx(long i,long =0,long =0) const
mgl2_8.0.1_(mathgl)/C-include/data.h:	mreal dvy(long ,long =0,long =0) const
mgl2_8.0.1_(mathgl)/C-include/data.h:	mreal dvz(long ,long =0,long =0) const
mgl2_8.0.1_(mathgl)/C-include/data.h:	mreal v(long i,long =0,long =0) const		{	return dat[i];	}
mgl2_8.0.1_(mathgl)/C-include/data.h:	mreal vthr(long i) const	{	return dat[i];	}
mgl2_8.0.1_(mathgl)/C-include/data.h:	long GetNx() const	{	return dat.size();	}
mgl2_8.0.1_(mathgl)/C-include/data.h:	long GetNy() const	{	return 1;	}
mgl2_8.0.1_(mathgl)/C-include/data.h:	long GetNz() const	{	return 1;	}
mgl2_8.0.1_(mathgl)/C-include/data.h:	mreal dvx(long i,long =0,long =0) const
mgl2_8.0.1_(mathgl)/C-include/data.h:	{	return i>0? (i<long(dat.size()-1)? (dat[i+1]-dat[i-1])/2:dat[i]-dat[i-1]) : dat[i+1]-dat[i];	}
mgl2_8.0.1_(mathgl)/C-include/data.h:	mreal dvy(long ,long =0,long =0) const	{	return 0;	}
mgl2_8.0.1_(mathgl)/C-include/data.h:	mreal dvz(long ,long =0,long =0) const	{	return 0;	}
mgl2_8.0.1_(mathgl)/C-include/evalc.h: *   License along with this program; if not, write to the                 *
mgl2_8.0.1_(mathgl)/C-include/other.h: *   License along with this program; if not, write to the                 *
mgl2_8.0.1_(mathgl)/C-include/mgl.h: *   along with this program; if not, write to the                         *
mgl2_8.0.1_(mathgl)/C-include/mgl.h:	inline void SetDrawReg(long nx=1, long ny=1, long m=0)	{	mgl_set_draw_reg(gr,nx,ny,m);	}
mgl2_8.0.1_(mathgl)/C-include/mgl.h:		long w=mgl_get_width(gr), h=mgl_get_height(gr);
mgl2_8.0.1_(mathgl)/C-include/mgl.h:		long w=mgl_get_width(gr), h=mgl_get_height(gr);
mgl2_8.0.1_(mathgl)/C-include/mgl.h:		long w=mgl_get_width(gr), h=mgl_get_height(gr), i;
mgl2_8.0.1_(mathgl)/C-include/mgl.h:		long w=mgl_get_width(gr), h=mgl_get_height(gr);
mgl2_8.0.1_(mathgl)/C-include/mgl.h:	inline int GetObjId(long x,long y)	{	return mgl_get_obj_id(gr,x,y);	}
mgl2_8.0.1_(mathgl)/C-include/mgl.h:	inline int GetSplId(long x,long y)	{	return mgl_get_spl_id(gr,x,y);	}
mgl2_8.0.1_(mathgl)/C-include/mgl.h:	inline long IsActive(int xs, int ys, int d=1)	{	return mgl_is_active(gr,xs,ys,d);	}
mgl2_8.0.1_(mathgl)/C-include/mgl.h:	/** Parameter \a shift set the degree of drop oblongness: ‘0’ is sphere, ‘1’ is maximally oblongness drop. Parameter \a ap set relative width of the drop (this is analogue of “ellipticity” for the sphere).*/
mgl2_8.0.1_(mathgl)/C-include/mgl.h:	/// Draws bitmap (logo) which is stretched along whole axis range
mgl2_8.0.1_(mathgl)/C-include/mgl.h:	inline void Logo(long w, long h, const unsigned char *rgba, bool smooth=false, const char *opt="")
mgl2_8.0.1_(mathgl)/C-include/mgl.h:	/// Draw user-defined symbol in position p along direction d
mgl2_8.0.1_(mathgl)/C-include/mgl.h:	/// Print text in position p along direction d with specified font
mgl2_8.0.1_(mathgl)/C-include/mgl.h:	/// Print text in position p along direction d with specified font
mgl2_8.0.1_(mathgl)/C-include/mgl.h:	/// Print text along the curve
mgl2_8.0.1_(mathgl)/C-include/mgl.h:	/// Print text along the curve
mgl2_8.0.1_(mathgl)/C-include/mgl.h:	/// Print text along the curve
mgl2_8.0.1_(mathgl)/C-include/mgl.h:	/// Print text along the curve
mgl2_8.0.1_(mathgl)/C-include/mgl.h:	/// Print text along the curve
mgl2_8.0.1_(mathgl)/C-include/mgl.h:	/// Print text along the curve
mgl2_8.0.1_(mathgl)/C-include/mgl.h:	/// Draw table for values val along given direction with row labels text
mgl2_8.0.1_(mathgl)/C-include/mgl.h:	/// Draw table for values val along given direction with row labels text
mgl2_8.0.1_(mathgl)/C-include/mgl.h:	/// Draw table for values val along given direction with row labels text at given position
mgl2_8.0.1_(mathgl)/C-include/mgl.h:	/// Draw table for values val along given direction with row labels text at given position
mgl2_8.0.1_(mathgl)/C-include/mgl.h:	/// Draw contour lines at manual levels along slice for 3d data specified parametrically
mgl2_8.0.1_(mathgl)/C-include/mgl.h:	/// Draw contour lines at manual levels along slice for 3d data
mgl2_8.0.1_(mathgl)/C-include/mgl.h:	/// Draw contour lines along slice for 3d data specified parametrically
mgl2_8.0.1_(mathgl)/C-include/mgl.h:	/// Draw contour lines along slice for 3d data
mgl2_8.0.1_(mathgl)/C-include/mgl.h:	/// Draw solid contours at manual levels along slice for 3d data specified parametrically
mgl2_8.0.1_(mathgl)/C-include/mgl.h:	/// Draw solid contours at manual levels along slice for 3d data
mgl2_8.0.1_(mathgl)/C-include/mgl.h:	/// Draw solid contours along slice for 3d data specified parametrically
mgl2_8.0.1_(mathgl)/C-include/mgl.h:	/// Draw solid contours along slice for 3d data
mgl2_8.0.1_(mathgl)/C-include/mgl.h:	/// Plot vectors at position {x,y} along {ax,ay} with length/color proportional to |a|
mgl2_8.0.1_(mathgl)/C-include/mgl.h:	/// Plot vectors at position {x,y,z} along {ax,ay,az} with length/color proportional to |a|
mgl2_8.0.1_(mathgl)/C-include/mgl.h:	 * ‘=’ for enabling color gradient along arrows. */
mgl2_8.0.1_(mathgl)/C-include/mgl.h:	 * ‘=’ for enabling color gradient along arrows. */
mgl2_8.0.1_(mathgl)/C-include/mgl.h:	 * ‘=’ for enabling color gradient along arrows. */
mgl2_8.0.1_(mathgl)/C-include/mgl.h:	 * ‘=’ for enabling color gradient along arrows. */
mgl2_8.0.1_(mathgl)/C-include/mgl.h:	/// Draw vector plot along slice for 3d data specified parametrically
mgl2_8.0.1_(mathgl)/C-include/mgl.h:	 * ‘=’ for enabling color gradient along arrows,
mgl2_8.0.1_(mathgl)/C-include/mgl.h:	/// Draw vector plot along slice for 3d data
mgl2_8.0.1_(mathgl)/C-include/mgl.h:	 * ‘=’ for enabling color gradient along arrows,
mgl2_8.0.1_(mathgl)/C-include/mgl.h:	/// Fit data along x-direction for each data row. Return array with values for found formula.
mgl2_8.0.1_(mathgl)/C-include/mgl.h:	/// Fit data along x-direction for each data row starting from \a ini values. Return array with values for found formula.
mgl2_8.0.1_(mathgl)/C-include/mgl.h:	/// Fit data along x-, y-directions for each data slice. Return array with values for found formula.
mgl2_8.0.1_(mathgl)/C-include/mgl.h:	/// Fit data along x-, y-direction for each data slice starting from \a ini values. Return array with values for found formula.
mgl2_8.0.1_(mathgl)/C-include/mgl.h:	/// Fit data along along all directions. Return array with values for found formula.
mgl2_8.0.1_(mathgl)/C-include/mgl.h:	/// Fit data along all directions starting from \a ini values. Return array with values for found formula.
mgl2_8.0.1_(mathgl)/C-include/mgl.h:	/// Fit data along x-direction for each data row. Return array with values for found formula.
mgl2_8.0.1_(mathgl)/C-include/mgl.h:	/// Fit data along x-direction for each data row starting from \a ini values. Return array with values for found formula.
mgl2_8.0.1_(mathgl)/C-include/mgl.h:	/// Fit data along x-, y-directions for each data slice. Return array with values for found formula.
mgl2_8.0.1_(mathgl)/C-include/mgl.h:	/// Fit data along x-, y-directions for each data slice starting from \a ini values. Return array with values for found formula.
mgl2_8.0.1_(mathgl)/C-include/mgl.h:	/// Fit data along along all directions. Return array with values for found formula.
mgl2_8.0.1_(mathgl)/C-include/mgl.h:	/// Fit data along along all directions starting from \a ini values. Return array with values for found formula.
mgl2_8.0.1_(mathgl)/C-include/mgl.h:	/// Fit data with dispersion s along x-direction for each data row. Return array with values for found formula.
mgl2_8.0.1_(mathgl)/C-include/mgl.h:	/// Fit data with dispersion s along x-direction for each data row starting from \a ini values. Return array with values for found formula.
mgl2_8.0.1_(mathgl)/C-include/mgl.h:	/// Fit data with dispersion s along x-direction for each data row. Return array with values for found formula.
mgl2_8.0.1_(mathgl)/C-include/mgl.h:	/// Fit data with dispersion s along x-direction for each data row starting from \a ini values. Return array with values for found formula.
mgl2_8.0.1_(mathgl)/C-include/mgl.h:	/// Fit data with dispersion s along x-, y-directions for each data slice. Return array with values for found formula.
mgl2_8.0.1_(mathgl)/C-include/mgl.h:	/// Fit data with dispersion s along x-, y-directions for each data slice starting from \a ini values. Return array with values for found formula.
mgl2_8.0.1_(mathgl)/C-include/mgl.h:	/// Fit data with dispersion s along all directions. Return array with values for found formula.
mgl2_8.0.1_(mathgl)/C-include/mgl.h:	/// Fit data with dispersion s along all directions starting from \a ini values. Return array with values for found formula.
mgl2_8.0.1_(mathgl)/C-include/mgl.h:	inline void Refill(mglData &dat, const mglDataA &xdat, const mglDataA &vdat, long sl=-1, const char *opt="")
mgl2_8.0.1_(mathgl)/C-include/mgl.h:	inline void Refill(mglData &dat, const mglDataA &xdat, const mglDataA &ydat, const mglDataA &vdat, long sl=-1, const char *opt="")
mgl2_8.0.1_(mathgl)/C-include/mgl.h:	inline void Refill(mglDataC &dat, const mglDataA &xdat, const mglDataA &vdat, long sl=-1, const char *opt="")
mgl2_8.0.1_(mathgl)/C-include/mgl.h:	inline void Refill(mglDataC &dat, const mglDataA &xdat, const mglDataA &ydat, const mglDataA &vdat, long sl=-1, const char *opt="")
mgl2_8.0.1_(mathgl)/C-include/mgl.h:	inline const char *GetCmdName(long n)
mgl2_8.0.1_(mathgl)/C-include/mgl.h:	inline long GetCmdNum()
mgl2_8.0.1_(mathgl)/C-include/mgl.h:	inline mglDataA *GetVar(unsigned long id)
mgl2_8.0.1_(mathgl)/C-include/mgl.h:	inline long GetNumVar()
mgl2_8.0.1_(mathgl)/C-include/mgl.h:	inline mglNum *GetConst(unsigned long id)
mgl2_8.0.1_(mathgl)/C-include/mgl.h:	inline long GetNumConst()
mgl2_8.0.1_(mathgl)/C-include/addon.h: *   License along with this program; if not, write to the                 *
mgl2_8.0.1_(mathgl)/C-include/addon.h:void MGL_EXPORT mgl_fft_freq(double *freq,long nn);
mgl2_8.0.1_(mathgl)/C-include/addon.h:long MGL_EXPORT_PURE mgl_strpos(const char *str,char *fnd);
mgl2_8.0.1_(mathgl)/C-include/addon.h:long MGL_EXPORT_PURE mgl_chrpos(const char *str,char fnd);
mgl2_8.0.1_(mathgl)/C-include/addon.h:MGL_EXPORT FILE *mgl_next_data(const char *fname,long p);
mgl2_8.0.1_(mathgl)/C-include/plot.h: *   License along with this program; if not, write to the                 *
mgl2_8.0.1_(mathgl)/C-include/wnd_cf.h: *   License along with this program; if not, write to the                 *
