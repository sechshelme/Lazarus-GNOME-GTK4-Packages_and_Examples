
unit ssl;
interface

{
  Automatically converted by H2Pas 1.0.0 from ssl.h
  The following command line parameters were used:
    -p
    -T
    -d
    -c
    -e
    ssl.h
}

    { Pointers to basic pascal types, inserted by h2pas conversion program.}
    Type
      PLongint  = ^Longint;
      PSmallInt = ^SmallInt;
      PByte     = ^Byte;
      PWord     = ^Word;
      PDWord    = ^DWord;
      PDouble   = ^Double;

    Type
    PBIO  = ^BIO;
    PBIO_ADDR  = ^BIO_ADDR;
    PBIO_METHOD  = ^BIO_METHOD;
    Pbyte  = ^byte;
    Pchar  = ^char;
    PCOMP_METHOD  = ^COMP_METHOD;
    PCTLOG_STORE  = ^CTLOG_STORE;
    Pdword  = ^dword;
    PENGINE  = ^ENGINE;
    PEVP_MD  = ^EVP_MD;
    PEVP_PKEY  = ^EVP_PKEY;
    PFILE  = ^FILE;
    Plongint  = ^longint;
    POPENSSL_INIT_SETTINGS  = ^OPENSSL_INIT_SETTINGS;
    Popenssl_ssl_test_functions  = ^openssl_ssl_test_functions;
    POSSL_ASYNC_FD  = ^OSSL_ASYNC_FD;
    POSSL_HANDSHAKE_STATE  = ^OSSL_HANDSHAKE_STATE;
    POSSL_LIB_CTX  = ^OSSL_LIB_CTX;
    Ppem_password_cb  = ^pem_password_cb;
    Psize_t  = ^size_t;
    PSRTP_PROTECTION_PROFILE  = ^SRTP_PROTECTION_PROFILE;
    Psrtp_protection_profile_st  = ^srtp_protection_profile_st;
    PSSL  = ^SSL;
    PSSL_CIPHER  = ^SSL_CIPHER;
    PSSL_COMP  = ^SSL_COMP;
    PSSL_CONF_CTX  = ^SSL_CONF_CTX;
    Pssl_crock_st  = ^ssl_crock_st;
    PSSL_CTX  = ^SSL_CTX;
    Pssl_ctx_st  = ^ssl_ctx_st;
    PSSL_DANE  = ^SSL_DANE;
    PSSL_METHOD  = ^SSL_METHOD;
    PSSL_SESSION  = ^SSL_SESSION;
    Pssl_st  = ^ssl_st;
    PSSL_TICKET_RETURN  = ^SSL_TICKET_RETURN;
    PSSL_TICKET_STATUS  = ^SSL_TICKET_STATUS;
    Pstack_st_SSL_CIPHERtype  = ^stack_st_SSL_CIPHERtype;
    Puint8_t  = ^uint8_t;
    PX509  = ^X509;
    PX509_STORE  = ^X509_STORE;
    PX509_STORE_CTX  = ^X509_STORE_CTX;
    PX509_VERIFY_PARAM  = ^X509_VERIFY_PARAM;
{$IFDEF FPC}
{$PACKRECORDS C}
{$ENDIF}


{
 * WARNING: do not edit!
 * Generated by Makefile from ../include/openssl/ssl.h.in
 *
 * Copyright 1995-2022 The OpenSSL Project Authors. All Rights Reserved.
 * Copyright (c) 2002, Oracle and/or its affiliates. All rights reserved
 * Copyright 2005 Nokia. All rights reserved.
 *
 * Licensed under the Apache License 2.0 (the "License").  You may not use
 * this file except in compliance with the License.  You can obtain a copy
 * in the file LICENSE in the source distribution or at
 * https://www.openssl.org/source/license.html
  }
{$ifndef OPENSSL_SSL_H}
{$define OPENSSL_SSL_H}
(** unsupported pragma#pragma once*)
{$include <openssl/macros.h>}
{$include <openssl/e_os2.h>}
{$include <openssl/opensslconf.h>}
{$include <openssl/comp.h>}
{$include <openssl/bio.h>}
{$include <openssl/lhash.h>}
{$include <openssl/pem.h>}
{$include <openssl/hmac.h>}
{$include <openssl/async.h>}
{$include <openssl/safestack.h>}
{$include <openssl/symhacks.h>}
{$include <openssl/ct.h>}
{$include <openssl/sslerr.h>}
{$include <openssl/prov_ssl.h>}
{ C++ extern C conditionnal removed }
{ OpenSSL version number for ASN.1 encoding of the session information  }
{-
 * Version 0 - initial version
 * Version 1 - added the optional peer certificate
  }

const
  SSL_SESSION_ASN1_VERSION = $0001;  
  SSL_MAX_SSL_SESSION_ID_LENGTH = 32;  
  SSL_MAX_SID_CTX_LENGTH = 32;  
  SSL_MIN_RSA_MODULUS_LENGTH_IN_BYTES = 512/8;  
  SSL_MAX_KEY_ARG_LENGTH = 8;  
{ SSL_MAX_MASTER_KEY_LENGTH is defined in prov_ssl.h  }
{ The maximum number of encrypt/decrypt pipelines we can support  }
  SSL_MAX_PIPELINES = 32;  
{ text strings for the ciphers  }
{ These are used to specify which ciphers to use and not to use  }
  SSL_TXT_LOW = 'LOW';  
  SSL_TXT_MEDIUM = 'MEDIUM';  
  SSL_TXT_HIGH = 'HIGH';  
  SSL_TXT_FIPS = 'FIPS';  
  SSL_TXT_aNULL = 'aNULL';  
  SSL_TXT_eNULL = 'eNULL';  
  SSL_TXT_NULL = 'NULL';  
  SSL_TXT_kRSA = 'kRSA';  
{ this cipher class has been removed  }
  SSL_TXT_kDHr = 'kDHr';  
{ this cipher class has been removed  }
  SSL_TXT_kDHd = 'kDHd';  
{ this cipher class has been removed  }
  SSL_TXT_kDH = 'kDH';  
{ alias for kDHE  }
  SSL_TXT_kEDH = 'kEDH';  
  SSL_TXT_kDHE = 'kDHE';  
{ this cipher class has been removed  }
  SSL_TXT_kECDHr = 'kECDHr';  
{ this cipher class has been removed  }
  SSL_TXT_kECDHe = 'kECDHe';  
{ this cipher class has been removed  }
  SSL_TXT_kECDH = 'kECDH';  
{ alias for kECDHE  }
  SSL_TXT_kEECDH = 'kEECDH';  
  SSL_TXT_kECDHE = 'kECDHE';  
  SSL_TXT_kPSK = 'kPSK';  
  SSL_TXT_kRSAPSK = 'kRSAPSK';  
  SSL_TXT_kECDHEPSK = 'kECDHEPSK';  
  SSL_TXT_kDHEPSK = 'kDHEPSK';  
  SSL_TXT_kGOST = 'kGOST';  
  SSL_TXT_kGOST18 = 'kGOST18';  
  SSL_TXT_kSRP = 'kSRP';  
  SSL_TXT_aRSA = 'aRSA';  
  SSL_TXT_aDSS = 'aDSS';  
{ this cipher class has been removed  }
  SSL_TXT_aDH = 'aDH';  
{ this cipher class has been removed  }
  SSL_TXT_aECDH = 'aECDH';  
  SSL_TXT_aECDSA = 'aECDSA';  
  SSL_TXT_aPSK = 'aPSK';  
  SSL_TXT_aGOST94 = 'aGOST94';  
  SSL_TXT_aGOST01 = 'aGOST01';  
  SSL_TXT_aGOST12 = 'aGOST12';  
  SSL_TXT_aGOST = 'aGOST';  
  SSL_TXT_aSRP = 'aSRP';  
  SSL_TXT_DSS = 'DSS';  
  SSL_TXT_DH = 'DH';  
{ same as "kDHE:-ADH"  }
  SSL_TXT_DHE = 'DHE';  
{ alias for DHE  }
  SSL_TXT_EDH = 'EDH';  
  SSL_TXT_ADH = 'ADH';  
  SSL_TXT_RSA = 'RSA';  
  SSL_TXT_ECDH = 'ECDH';  
{ alias for ECDHE"  }
  SSL_TXT_EECDH = 'EECDH';  
{ same as "kECDHE:-AECDH"  }
  SSL_TXT_ECDHE = 'ECDHE';  
  SSL_TXT_AECDH = 'AECDH';  
  SSL_TXT_ECDSA = 'ECDSA';  
  SSL_TXT_PSK = 'PSK';  
  SSL_TXT_SRP = 'SRP';  
  SSL_TXT_DES = 'DES';  
  SSL_TXT_3DES = '3DES';  
  SSL_TXT_RC4 = 'RC4';  
  SSL_TXT_RC2 = 'RC2';  
  SSL_TXT_IDEA = 'IDEA';  
  SSL_TXT_SEED = 'SEED';  
  SSL_TXT_AES128 = 'AES128';  
  SSL_TXT_AES256 = 'AES256';  
  SSL_TXT_AES = 'AES';  
  SSL_TXT_AES_GCM = 'AESGCM';  
  SSL_TXT_AES_CCM = 'AESCCM';  
  SSL_TXT_AES_CCM_8 = 'AESCCM8';  
  SSL_TXT_CAMELLIA128 = 'CAMELLIA128';  
  SSL_TXT_CAMELLIA256 = 'CAMELLIA256';  
  SSL_TXT_CAMELLIA = 'CAMELLIA';  
  SSL_TXT_CHACHA20 = 'CHACHA20';  
  SSL_TXT_GOST = 'GOST89';  
  SSL_TXT_ARIA = 'ARIA';  
  SSL_TXT_ARIA_GCM = 'ARIAGCM';  
  SSL_TXT_ARIA128 = 'ARIA128';  
  SSL_TXT_ARIA256 = 'ARIA256';  
  SSL_TXT_GOST2012_GOST8912_GOST8912 = 'GOST2012-GOST8912-GOST8912';  
  SSL_TXT_CBC = 'CBC';  
  SSL_TXT_MD5 = 'MD5';  
  SSL_TXT_SHA1 = 'SHA1';  
{ same as "SHA1"  }
  SSL_TXT_SHA = 'SHA';  
  SSL_TXT_GOST94 = 'GOST94';  
  SSL_TXT_GOST89MAC = 'GOST89MAC';  
  SSL_TXT_GOST12 = 'GOST12';  
  SSL_TXT_GOST89MAC12 = 'GOST89MAC12';  
  SSL_TXT_SHA256 = 'SHA256';  
  SSL_TXT_SHA384 = 'SHA384';  
  SSL_TXT_SSLV3 = 'SSLv3';  
  SSL_TXT_TLSV1 = 'TLSv1';  
  SSL_TXT_TLSV1_1 = 'TLSv1.1';  
  SSL_TXT_TLSV1_2 = 'TLSv1.2';  
  SSL_TXT_ALL = 'ALL';  
{-
 * COMPLEMENTOF* definitions. These identifiers are used to (de-select)
 * ciphers normally not being used.
 * Example: "RC4" will activate all ciphers using RC4 including ciphers
 * without authentication, which would normally disabled by DEFAULT (due
 * the "!ADH" being part of default). Therefore "RC4:!COMPLEMENTOFDEFAULT"
 * will make sure that it is also disabled in the specific selection.
 * COMPLEMENTOF* identifiers are portable between version, as adjustments
 * to the default cipher setup will also be included here.
 *
 * COMPLEMENTOFDEFAULT does not experience the same special treatment that
 * DEFAULT gets, as only selection is being done and no sorting as needed
 * for DEFAULT.
  }
  SSL_TXT_CMPALL = 'COMPLEMENTOFALL';  
  SSL_TXT_CMPDEF = 'COMPLEMENTOFDEFAULT';  
{
 * The following cipher list is used by default. It also is substituted when
 * an application-defined cipher list string starts with 'DEFAULT'.
 * This applies to ciphersuites for TLSv1.2 and below.
 * DEPRECATED IN 3.0.0, in favor of OSSL_default_cipher_list()
 * Update both macro and function simultaneously
  }
{
 * As of OpenSSL 1.0.0, ssl_create_cipher_list() in ssl/ssl_ciph.c always
 * starts with a reasonable order, and all we have to do for DEFAULT is
 * throwing out anonymous and unencrypted ciphersuites! (The latter are not
 * actually enabled by ALL, but "ALL:RSA" would enable some of them.)
  }
{ Used in SSL_set_shutdown()/SSL_get_shutdown();  }
  SSL_SENT_SHUTDOWN = 1;  
  SSL_RECEIVED_SHUTDOWN = 2;  
{ C++ end of extern C conditionnal removed }
{ C++ extern C conditionnal removed }
  SSL_FILETYPE_ASN1 = X509_FILETYPE_ASN1;  
  SSL_FILETYPE_PEM = X509_FILETYPE_PEM;  
{
 * This is needed to stop compilers complaining about the 'struct ssl_st *'
 * function parameters used to prototype callbacks in SSL_CTX.
  }
type
  Pssl_crock_st = ^Tssl_crock_st;
  Tssl_crock_st = Pssl_st;
  Ttls_session_ticket_ext_st = TTLS_SESSION_TICKET_EXT;
  Tssl_method_st = TSSL_METHOD;
  Tssl_cipher_st = TSSL_CIPHER;
  Tssl_session_st = TSSL_SESSION;
  Ttls_sigalgs_st = TTLS_SIGALGS;
  Tssl_conf_ctx_st = TSSL_CONF_CTX;
  Tssl_comp_st = TSSL_COMP;
(* error 
stack_st_SSL_CIPHERtype;
in declaration at line 217 *)
      var
        SSL_COMP : TSTACK_OF;cvar;public;
    { SRTP protection profiles for use with the use_srtp extension (RFC 5764) }
(* Const before type ignored *)
    type
      Psrtp_protection_profile_st = ^Tsrtp_protection_profile_st;
      Tsrtp_protection_profile_st = record
          name : Pchar;
          id : dword;
        end;
      TSRTP_PROTECTION_PROFILE = Tsrtp_protection_profile_st;
      PSRTP_PROTECTION_PROFILE = ^TSRTP_PROTECTION_PROFILE;
(* Const before type ignored *)

      Ttls_session_ticket_ext_cb_fn = function (s:PSSL; data:Pbyte; len:longint; arg:pointer):longint;cdecl;
(* Const before type ignored *)

      Ttls_session_secret_cb_fn = function (s:PSSL; secret:pointer; secret_len:Plongint; peer_ciphers:Pstack_st_SSL_CIPHERtype; cipher:PPSSL_CIPHER; 
                   arg:pointer):longint;cdecl;
    { Extension context codes  }
    { This extension is only allowed in TLS  }

    const
      SSL_EXT_TLS_ONLY = $0001;      
    { This extension is only allowed in DTLS  }
      SSL_EXT_DTLS_ONLY = $0002;      
    { Some extensions may be allowed in DTLS but we don't implement them for it  }
      SSL_EXT_TLS_IMPLEMENTATION_ONLY = $0004;      
    { Most extensions are not defined for SSLv3 but EXT_TYPE_renegotiate is  }
      SSL_EXT_SSL3_ALLOWED = $0008;      
    { Extension is only defined for TLS1.2 and below  }
      SSL_EXT_TLS1_2_AND_BELOW_ONLY = $0010;      
    { Extension is only defined for TLS1.3 and above  }
      SSL_EXT_TLS1_3_ONLY = $0020;      
    { Ignore this extension during parsing if we are resuming  }
      SSL_EXT_IGNORE_ON_RESUMPTION = $0040;      
      SSL_EXT_CLIENT_HELLO = $0080;      
    { Really means TLS1.2 or below  }
      SSL_EXT_TLS1_2_SERVER_HELLO = $0100;      
      SSL_EXT_TLS1_3_SERVER_HELLO = $0200;      
      SSL_EXT_TLS1_3_ENCRYPTED_EXTENSIONS = $0400;      
      SSL_EXT_TLS1_3_HELLO_RETRY_REQUEST = $0800;      
      SSL_EXT_TLS1_3_CERTIFICATE = $1000;      
      SSL_EXT_TLS1_3_NEW_SESSION_TICKET = $2000;      
      SSL_EXT_TLS1_3_CERTIFICATE_REQUEST = $4000;      
    { Typedefs for handling custom extensions  }
(* Const before type ignored *)
    type

      Tcustom_ext_add_cb = function (s:PSSL; ext_type:dword; out:PPbyte; outlen:Psize_t; al:Plongint; 
                   add_arg:pointer):longint;cdecl;
(* Const before type ignored *)

      Tcustom_ext_free_cb = procedure (s:PSSL; ext_type:dword; out:Pbyte; add_arg:pointer);cdecl;
(* Const before type ignored *)

      Tcustom_ext_parse_cb = function (s:PSSL; ext_type:dword; in:Pbyte; inlen:Tsize_t; al:Plongint; 
                   parse_arg:pointer):longint;cdecl;
(* Const before type ignored *)

      TSSL_custom_ext_add_cb_ex = function (s:PSSL; ext_type:dword; context:dword; out:PPbyte; outlen:Psize_t; 
                   x:PX509; chainidx:Tsize_t; al:Plongint; add_arg:pointer):longint;cdecl;
(* Const before type ignored *)

      TSSL_custom_ext_free_cb_ex = procedure (s:PSSL; ext_type:dword; context:dword; out:Pbyte; add_arg:pointer);cdecl;
(* Const before type ignored *)

      TSSL_custom_ext_parse_cb_ex = function (s:PSSL; ext_type:dword; context:dword; in:Pbyte; inlen:Tsize_t; 
                   x:PX509; chainidx:Tsize_t; al:Plongint; parse_arg:pointer):longint;cdecl;
    { Typedef for verification callback  }

      TSSL_verify_cb = function (preverify_ok:longint; x509_ctx:PX509_STORE_CTX):longint;cdecl;
    { Typedef for SSL async callback  }

      TSSL_async_callback_fn = function (s:PSSL; arg:pointer):longint;cdecl;
    { was #define dname(params) para_def_expr }
    { argument types are unknown }
    { return type might be wrong }   

    function SSL_OP_BIT(n : longint) : longint;    

    {
     * SSL/TLS connection options.
      }
    { Disable Extended master secret  }
    { was #define dname def_expr }
    function SSL_OP_NO_EXTENDED_MASTER_SECRET : longint; { return type might be wrong }

    { Cleanse plaintext copies of data delivered to the application  }
    { was #define dname def_expr }
    function SSL_OP_CLEANSE_PLAINTEXT : longint; { return type might be wrong }

    { Allow initial connection to servers that don't support RI  }
    { was #define dname def_expr }
    function SSL_OP_LEGACY_SERVER_CONNECT : longint; { return type might be wrong }

    { Enable support for Kernel TLS  }
    { was #define dname def_expr }
    function SSL_OP_ENABLE_KTLS : longint; { return type might be wrong }

    { was #define dname def_expr }
    function SSL_OP_TLSEXT_PADDING : longint; { return type might be wrong }

    { was #define dname def_expr }
    function SSL_OP_SAFARI_ECDHE_ECDSA_BUG : longint; { return type might be wrong }

    { was #define dname def_expr }
    function SSL_OP_IGNORE_UNEXPECTED_EOF : longint; { return type might be wrong }

    { was #define dname def_expr }
    function SSL_OP_ALLOW_CLIENT_RENEGOTIATION : longint; { return type might be wrong }

    { was #define dname def_expr }
    function SSL_OP_DISABLE_TLSEXT_CA_NAMES : longint; { return type might be wrong }

    { In TLSv1.3 allow a non-(ec)dhe based kex_mode  }
    { was #define dname def_expr }
    function SSL_OP_ALLOW_NO_DHE_KEX : longint; { return type might be wrong }

    {
         * Disable SSL 3.0/TLS 1.0 CBC vulnerability workaround that was added
         * in OpenSSL 0.9.6d.  Usually (depending on the application protocol)
         * the workaround is not needed.  Unfortunately some broken SSL/TLS
         * implementations cannot handle it at all, which is why we include it
         * in SSL_OP_ALL. Added in 0.9.6e
          }
    { was #define dname def_expr }
    function SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS : longint; { return type might be wrong }

    { DTLS options  }
    { was #define dname def_expr }
    function SSL_OP_NO_QUERY_MTU : longint; { return type might be wrong }

    { Turn on Cookie Exchange (on relevant for servers)  }
    { was #define dname def_expr }
    function SSL_OP_COOKIE_EXCHANGE : longint; { return type might be wrong }

    { Don't use RFC4507 ticket extension  }
    { was #define dname def_expr }
    function SSL_OP_NO_TICKET : longint; { return type might be wrong }

{$ifndef OPENSSL_NO_DTLS1_METHOD}
    {
         * Use Cisco's version identifier of DTLS_BAD_VER
         * (only with deprecated DTLSv1_client_method())
          }

    { was #define dname def_expr }
    function SSL_OP_CISCO_ANYCONNECT : longint; { return type might be wrong }

{$endif}
    { As server, disallow session resumption on renegotiation  }

    { was #define dname def_expr }
    function SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION : longint; { return type might be wrong }

    { Don't use compression even if supported  }
    { was #define dname def_expr }
    function SSL_OP_NO_COMPRESSION : longint; { return type might be wrong }

    { Permit unsafe legacy renegotiation  }
    { was #define dname def_expr }
    function SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION : longint; { return type might be wrong }

    { Disable encrypt-then-mac  }
    { was #define dname def_expr }
    function SSL_OP_NO_ENCRYPT_THEN_MAC : longint; { return type might be wrong }

    {
         * Enable TLSv1.3 Compatibility mode. This is on by default. A future
         * version of OpenSSL may have this disabled by default.
          }
    { was #define dname def_expr }
    function SSL_OP_ENABLE_MIDDLEBOX_COMPAT : longint; { return type might be wrong }

    {
         * Prioritize Chacha20Poly1305 when client does.
         * Modifies SSL_OP_CIPHER_SERVER_PREFERENCE
          }
    { was #define dname def_expr }
    function SSL_OP_PRIORITIZE_CHACHA : longint; { return type might be wrong }

    {
         * Set on servers to choose the cipher according to server's preferences.
          }
    { was #define dname def_expr }
    function SSL_OP_CIPHER_SERVER_PREFERENCE : longint; { return type might be wrong }

    {
         * If set, a server will allow a client to issue a SSLv3.0 version
         * number as latest version supported in the premaster secret, even when
         * TLSv1.0 (version 3.1) was announced in the client hello. Normally
         * this is forbidden to prevent version rollback attacks.
          }
    { was #define dname def_expr }
    function SSL_OP_TLS_ROLLBACK_BUG : longint; { return type might be wrong }

    {
         * Switches off automatic TLSv1.3 anti-replay protection for early data.
         * This is a server-side option only (no effect on the client).
          }
    { was #define dname def_expr }
    function SSL_OP_NO_ANTI_REPLAY : longint; { return type might be wrong }

    { was #define dname def_expr }
    function SSL_OP_NO_SSLv3 : longint; { return type might be wrong }

    { was #define dname def_expr }
    function SSL_OP_NO_TLSv1 : longint; { return type might be wrong }

    { was #define dname def_expr }
    function SSL_OP_NO_TLSv1_2 : longint; { return type might be wrong }

    { was #define dname def_expr }
    function SSL_OP_NO_TLSv1_1 : longint; { return type might be wrong }

    { was #define dname def_expr }
    function SSL_OP_NO_TLSv1_3 : longint; { return type might be wrong }

    { was #define dname def_expr }
    function SSL_OP_NO_DTLSv1 : longint; { return type might be wrong }

    { was #define dname def_expr }
    function SSL_OP_NO_DTLSv1_2 : longint; { return type might be wrong }

    { Disallow all renegotiation  }
    { was #define dname def_expr }
    function SSL_OP_NO_RENEGOTIATION : longint; { return type might be wrong }

    {
         * Make server add server-hello extension from early version of
         * cryptopro draft, when GOST ciphersuite is negotiated. Required for
         * interoperability with CryptoPro CSP 3.x
          }
    { was #define dname def_expr }
    function SSL_OP_CRYPTOPRO_TLSEXT_BUG : longint; { return type might be wrong }

    {
     * Option "collections."
      }
    const
      SSL_OP_NO_SSL_MASK = (((SSL_OP_NO_SSLv3 or SSL_OP_NO_TLSv1) or SSL_OP_NO_TLSv1_1) or SSL_OP_NO_TLSv1_2) or SSL_OP_NO_TLSv1_3;      
      SSL_OP_NO_DTLS_MASK = SSL_OP_NO_DTLSv1 or SSL_OP_NO_DTLSv1_2;      
    { Various bug workarounds that should be rather harmless.  }
      SSL_OP_ALL = ((SSL_OP_CRYPTOPRO_TLSEXT_BUG or SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS) or SSL_OP_TLSEXT_PADDING) or SSL_OP_SAFARI_ECDHE_ECDSA_BUG;      
    {
     * Allow SSL_write(..., n) to return r with 0 < r < n (i.e. report success
     * when just a single record has been written):
      }
      SSL_MODE_ENABLE_PARTIAL_WRITE = $00000001;      
    {
     * Make it possible to retry SSL_write() with changed buffer location (buffer
     * contents must stay the same!); this is not the default to avoid the
     * misconception that non-blocking SSL_write() behaves like non-blocking
     * write():
      }
      SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER = $00000002;      
    {
     * Never bother the application with retries if the transport is blocking:
      }
      SSL_MODE_AUTO_RETRY = $00000004;      
    { Don't attempt to automatically build certificate chain  }
      SSL_MODE_NO_AUTO_CHAIN = $00000008;      
    {
     * Save RAM by releasing read and write buffers when they're empty. (SSL3 and
     * TLS only.) Released buffers are freed.
      }
      SSL_MODE_RELEASE_BUFFERS = $00000010;      
    {
     * Send the current time in the Random fields of the ClientHello and
     * ServerHello records for compatibility with hypothetical implementations
     * that require it.
      }
      SSL_MODE_SEND_CLIENTHELLO_TIME = $00000020;      
      SSL_MODE_SEND_SERVERHELLO_TIME = $00000040;      
    {
     * Send TLS_FALLBACK_SCSV in the ClientHello. To be set only by applications
     * that reconnect with a downgraded protocol version; see
     * draft-ietf-tls-downgrade-scsv-00 for details. DO NOT ENABLE THIS if your
     * application attempts a normal handshake. Only use this in explicit
     * fallback retries, following the guidance in
     * draft-ietf-tls-downgrade-scsv-00.
      }
      SSL_MODE_SEND_FALLBACK_SCSV = $00000080;      
    {
     * Support Asynchronous operation
      }
      SSL_MODE_ASYNC = $00000100;      
    {
     * When using DTLS/SCTP, include the terminating zero in the label
     * used for computing the endpoint-pair shared secret. Required for
     * interoperability with implementations having this bug like these
     * older version of OpenSSL:
     * - OpenSSL 1.0.0 series
     * - OpenSSL 1.0.1 series
     * - OpenSSL 1.0.2 series
     * - OpenSSL 1.1.0 series
     * - OpenSSL 1.1.1 and 1.1.1a
      }
      SSL_MODE_DTLS_SCTP_LABEL_LENGTH_BUG = $00000400;      
    { Cert related flags  }
    {
     * Many implementations ignore some aspects of the TLS standards such as
     * enforcing certificate chain algorithms. When this is set we enforce them.
      }
      SSL_CERT_FLAG_TLS_STRICT = $00000001;      
    { Suite B modes, takes same values as certificate verify flags  }
      SSL_CERT_FLAG_SUITEB_128_LOS_ONLY = $10000;      
    { Suite B 192 bit only mode  }
      SSL_CERT_FLAG_SUITEB_192_LOS = $20000;      
    { Suite B 128 bit mode allowing 192 bit algorithms  }
      SSL_CERT_FLAG_SUITEB_128_LOS = $30000;      
    { Perform all sorts of protocol violations for testing purposes  }
      SSL_CERT_FLAG_BROKEN_PROTOCOL = $10000000;      
    { Flags for building certificate chains  }
    { Treat any existing certificates as untrusted CAs  }
      SSL_BUILD_CHAIN_FLAG_UNTRUSTED = $1;      
    { Don't include root CA in chain  }
      SSL_BUILD_CHAIN_FLAG_NO_ROOT = $2;      
    { Just check certificates already there  }
      SSL_BUILD_CHAIN_FLAG_CHECK = $4;      
    { Ignore verification errors  }
      SSL_BUILD_CHAIN_FLAG_IGNORE_ERROR = $8;      
    { Clear verification errors from queue  }
      SSL_BUILD_CHAIN_FLAG_CLEAR_ERROR = $10;      
    { Flags returned by SSL_check_chain  }
    { Certificate can be used with this session  }
      CERT_PKEY_VALID = $1;      
    { Certificate can also be used for signing  }
      CERT_PKEY_SIGN = $2;      
    { EE certificate signing algorithm OK  }
      CERT_PKEY_EE_SIGNATURE = $10;      
    { CA signature algorithms OK  }
      CERT_PKEY_CA_SIGNATURE = $20;      
    { EE certificate parameters OK  }
      CERT_PKEY_EE_PARAM = $40;      
    { CA certificate parameters OK  }
      CERT_PKEY_CA_PARAM = $80;      
    { Signing explicitly allowed as opposed to SHA1 fallback  }
      CERT_PKEY_EXPLICIT_SIGN = $100;      
    { Client CA issuer names match (always set for server cert)  }
      CERT_PKEY_ISSUER_NAME = $200;      
    { Cert type matches client types (always set for server cert)  }
      CERT_PKEY_CERT_TYPE = $400;      
    { Cert chain suitable to Suite B  }
      CERT_PKEY_SUITEB = $800;      
      SSL_CONF_FLAG_CMDLINE = $1;      
      SSL_CONF_FLAG_FILE = $2;      
      SSL_CONF_FLAG_CLIENT = $4;      
      SSL_CONF_FLAG_SERVER = $8;      
      SSL_CONF_FLAG_SHOW_ERRORS = $10;      
      SSL_CONF_FLAG_CERTIFICATE = $20;      
      SSL_CONF_FLAG_REQUIRE_PRIVATE = $40;      
    { Configuration value types  }
      SSL_CONF_TYPE_UNKNOWN = $0;      
      SSL_CONF_TYPE_STRING = $1;      
      SSL_CONF_TYPE_FILE = $2;      
      SSL_CONF_TYPE_DIR = $3;      
      SSL_CONF_TYPE_NONE = $4;      
      SSL_CONF_TYPE_STORE = $5;      
    { Maximum length of the application-controlled segment of a a TLSv1.3 cookie  }
      SSL_COOKIE_LENGTH = 4096;      
    {
     * Note: SSL[_CTX]_set_options,mode use |= op on the previous value, they
     * cannot be used to clear bits.
      }
(* Const before type ignored *)

function SSL_CTX_get_options(ctx:PSSL_CTX):Tuint64_t;cdecl;external;
(* Const before type ignored *)
function SSL_get_options(s:PSSL):Tuint64_t;cdecl;external;
function SSL_CTX_clear_options(ctx:PSSL_CTX; op:Tuint64_t):Tuint64_t;cdecl;external;
function SSL_clear_options(s:PSSL; op:Tuint64_t):Tuint64_t;cdecl;external;
function SSL_CTX_set_options(ctx:PSSL_CTX; op:Tuint64_t):Tuint64_t;cdecl;external;
function SSL_set_options(s:PSSL; op:Tuint64_t):Tuint64_t;cdecl;external;
(* Const before type ignored *)
procedure SSL_CTX_set_msg_callback(ctx:PSSL_CTX; cb:procedure (write_p:longint; version:longint; content_type:longint; buf:pointer; len:Tsize_t; 
                            ssl:PSSL; arg:pointer));cdecl;external;
(* Const before type ignored *)
procedure SSL_set_msg_callback(ssl:PSSL; cb:procedure (write_p:longint; version:longint; content_type:longint; buf:pointer; len:Tsize_t; 
                            ssl:PSSL; arg:pointer));cdecl;external;
    { was #define dname(params) para_def_expr }
    { argument types are unknown }
    { return type might be wrong }   
    function SSL_get_extms_support(s : longint) : longint;    

    { 100k max cert list  }
    const
      SSL_MAX_CERT_LIST_DEFAULT = 1024*100;      
      SSL_SESSION_CACHE_MAX_SIZE_DEFAULT = 1024*20;      
    {
     * This callback type is used inside SSL_CTX, SSL, and in the functions that
     * set them. It is used to override the generation of SSL/TLS session IDs in
     * a server. Return value should be zero on an error, non-zero to proceed.
     * Also, callbacks should themselves check if the id they generate is unique
     * otherwise the SSL handshake will fail with an error - callbacks can do
     * this using the 'ssl' value they're passed by;
     * SSL_has_matching_session_id(ssl, id, *id_len) The length value passed in
     * is set at the maximum size the session ID can be. In SSLv3/TLSv1 it is 32
     * bytes. The callback can alter this length to be less if desired. It is
     * also an error for the callback to set the size to zero.
      }
    type

      TGEN_SESSION_CB = function (ssl:PSSL; id:Pbyte; id_len:Pdword):longint;cdecl;

    const
      SSL_SESS_CACHE_OFF = $0000;      
      SSL_SESS_CACHE_CLIENT = $0001;      
      SSL_SESS_CACHE_SERVER = $0002;      
      SSL_SESS_CACHE_BOTH = SSL_SESS_CACHE_CLIENT or SSL_SESS_CACHE_SERVER;      
      SSL_SESS_CACHE_NO_AUTO_CLEAR = $0080;      
    { enough comments already ... see SSL_CTX_set_session_cache_mode(3)  }
      SSL_SESS_CACHE_NO_INTERNAL_LOOKUP = $0100;      
      SSL_SESS_CACHE_NO_INTERNAL_STORE = $0200;      
      SSL_SESS_CACHE_NO_INTERNAL = SSL_SESS_CACHE_NO_INTERNAL_LOOKUP or SSL_SESS_CACHE_NO_INTERNAL_STORE;      
      SSL_SESS_CACHE_UPDATE_TIME = $0400;      

procedure SSL_CTX_sess_set_new_cb(ctx:PSSL_CTX; new_session_cb:function (ssl:Pssl_st; sess:PSSL_SESSION):longint);cdecl;external;
function SSL_CTX_sess_get_new_cb(ctx:PSSL_CTX):function (ssl:Pssl_st; sess:PSSL_SESSION):longint;cdecl;external;
procedure SSL_CTX_sess_set_remove_cb(ctx:PSSL_CTX; remove_session_cb:procedure (ctx:Pssl_ctx_st; sess:PSSL_SESSION));cdecl;external;
function SSL_CTX_sess_get_remove_cb(ctx:PSSL_CTX):procedure (ctx:Pssl_ctx_st; sess:PSSL_SESSION);cdecl;external;
(* Const before type ignored *)
procedure SSL_CTX_sess_set_get_cb(ctx:PSSL_CTX; get_session_cb:function (ssl:Pssl_st; data:Pbyte; len:longint; copy:Plongint):PSSL_SESSION);cdecl;external;
(* Const before type ignored *)
function SSL_CTX_sess_get_get_cb(ctx:PSSL_CTX):function (ssl:Pssl_st; data:Pbyte; len:longint; copy:Plongint):PSSL_SESSION;cdecl;external;
(* Const before type ignored *)
procedure SSL_CTX_set_info_callback(ctx:PSSL_CTX; cb:procedure (ssl:PSSL; _type:longint; val:longint));cdecl;external;
(* Const before type ignored *)
function SSL_CTX_get_info_callback(ctx:PSSL_CTX):procedure (ssl:PSSL; _type:longint; val:longint);cdecl;external;
procedure SSL_CTX_set_client_cert_cb(ctx:PSSL_CTX; client_cert_cb:function (ssl:PSSL; x509:PPX509; pkey:PPEVP_PKEY):longint);cdecl;external;
function SSL_CTX_get_client_cert_cb(ctx:PSSL_CTX):function (ssl:PSSL; x509:PPX509; pkey:PPEVP_PKEY):longint;cdecl;external;
{$ifndef OPENSSL_NO_ENGINE}

function SSL_CTX_set_client_cert_engine(ctx:PSSL_CTX; e:PENGINE):longint;cdecl;external;
{$endif}

procedure SSL_CTX_set_cookie_generate_cb(ctx:PSSL_CTX; app_gen_cookie_cb:function (ssl:PSSL; cookie:Pbyte; cookie_len:Pdword):longint);cdecl;external;
(* Const before type ignored *)
procedure SSL_CTX_set_cookie_verify_cb(ctx:PSSL_CTX; app_verify_cookie_cb:function (ssl:PSSL; cookie:Pbyte; cookie_len:dword):longint);cdecl;external;
procedure SSL_CTX_set_stateless_cookie_generate_cb(ctx:PSSL_CTX; gen_stateless_cookie_cb:function (ssl:PSSL; cookie:Pbyte; cookie_len:Psize_t):longint);cdecl;external;
(* Const before type ignored *)
procedure SSL_CTX_set_stateless_cookie_verify_cb(ctx:PSSL_CTX; verify_stateless_cookie_cb:function (ssl:PSSL; cookie:Pbyte; cookie_len:Tsize_t):longint);cdecl;external;
{$ifndef OPENSSL_NO_NEXTPROTONEG}
(* Const before type ignored *)
    type

      TSSL_CTX_npn_advertised_cb_func = function (ssl:PSSL; out:PPbyte; outlen:Pdword; arg:pointer):longint;cdecl;

procedure SSL_CTX_set_next_protos_advertised_cb(s:PSSL_CTX; cb:TSSL_CTX_npn_advertised_cb_func; arg:pointer);cdecl;external;
    const
      SSL_CTX_set_npn_advertised_cb = SSL_CTX_set_next_protos_advertised_cb;      
(* Const before type ignored *)
    type

      TSSL_CTX_npn_select_cb_func = function (s:PSSL; out:PPbyte; outlen:Pbyte; in:Pbyte; inlen:dword; 
                   arg:pointer):longint;cdecl;

procedure SSL_CTX_set_next_proto_select_cb(s:PSSL_CTX; cb:TSSL_CTX_npn_select_cb_func; arg:pointer);cdecl;external;
    const
      SSL_CTX_set_npn_select_cb = SSL_CTX_set_next_proto_select_cb;      
(* Const before type ignored *)
(* Const before type ignored *)

procedure SSL_get0_next_proto_negotiated(s:PSSL; data:PPbyte; len:Pdword);cdecl;external;
    const
      SSL_get0_npn_negotiated = SSL_get0_next_proto_negotiated;      
{$endif}
(* Const before type ignored *)
(* Const before type ignored *)

function SSL_select_next_proto(out:PPbyte; outlen:Pbyte; in:Pbyte; inlen:dword; client:Pbyte; 
               client_len:dword):longint;cdecl;external;
    const
      OPENSSL_NPN_UNSUPPORTED = 0;      
      OPENSSL_NPN_NEGOTIATED = 1;      
      OPENSSL_NPN_NO_OVERLAP = 2;      
(* Const before type ignored *)

function SSL_CTX_set_alpn_protos(ctx:PSSL_CTX; protos:Pbyte; protos_len:dword):longint;cdecl;external;
(* Const before type ignored *)
function SSL_set_alpn_protos(ssl:PSSL; protos:Pbyte; protos_len:dword):longint;cdecl;external;
(* Const before type ignored *)
(* Const before type ignored *)
    type

      TSSL_CTX_alpn_select_cb_func = function (ssl:PSSL; out:PPbyte; outlen:Pbyte; in:Pbyte; inlen:dword; 
                   arg:pointer):longint;cdecl;

procedure SSL_CTX_set_alpn_select_cb(ctx:PSSL_CTX; cb:TSSL_CTX_alpn_select_cb_func; arg:pointer);cdecl;external;
(* Const before type ignored *)
(* Const before type ignored *)
procedure SSL_get0_alpn_selected(ssl:PSSL; data:PPbyte; len:Pdword);cdecl;external;
{$ifndef OPENSSL_NO_PSK}
    {
     * the maximum length of the buffer given to callbacks containing the
     * resulting identity/psk
      }

    const
      PSK_MAX_IDENTITY_LEN = 256;      
      PSK_MAX_PSK_LEN = 512;      
(* Const before type ignored *)
    type

      TSSL_psk_client_cb_func = function (ssl:PSSL; hint:Pchar; identity:Pchar; max_identity_len:dword; psk:Pbyte; 
                   max_psk_len:dword):dword;cdecl;

procedure SSL_CTX_set_psk_client_callback(ctx:PSSL_CTX; cb:TSSL_psk_client_cb_func);cdecl;external;
procedure SSL_set_psk_client_callback(ssl:PSSL; cb:TSSL_psk_client_cb_func);cdecl;external;
(* Const before type ignored *)
    type

      TSSL_psk_server_cb_func = function (ssl:PSSL; identity:Pchar; psk:Pbyte; max_psk_len:dword):dword;cdecl;

procedure SSL_CTX_set_psk_server_callback(ctx:PSSL_CTX; cb:TSSL_psk_server_cb_func);cdecl;external;
procedure SSL_set_psk_server_callback(ssl:PSSL; cb:TSSL_psk_server_cb_func);cdecl;external;
(* Const before type ignored *)
function SSL_CTX_use_psk_identity_hint(ctx:PSSL_CTX; identity_hint:Pchar):longint;cdecl;external;
(* Const before type ignored *)
function SSL_use_psk_identity_hint(s:PSSL; identity_hint:Pchar):longint;cdecl;external;
(* Const before type ignored *)
(* Const before type ignored *)
function SSL_get_psk_identity_hint(s:PSSL):Pchar;cdecl;external;
(* Const before type ignored *)
(* Const before type ignored *)
function SSL_get_psk_identity(s:PSSL):Pchar;cdecl;external;
{$endif}
(* Const before type ignored *)
    type

      TSSL_psk_find_session_cb_func = function (ssl:PSSL; identity:Pbyte; identity_len:Tsize_t; sess:PPSSL_SESSION):longint;cdecl;
(* Const before type ignored *)
(* Const before type ignored *)

      TSSL_psk_use_session_cb_func = function (ssl:PSSL; md:PEVP_MD; id:PPbyte; idlen:Psize_t; sess:PPSSL_SESSION):longint;cdecl;

procedure SSL_set_psk_find_session_callback(s:PSSL; cb:TSSL_psk_find_session_cb_func);cdecl;external;
procedure SSL_CTX_set_psk_find_session_callback(ctx:PSSL_CTX; cb:TSSL_psk_find_session_cb_func);cdecl;external;
procedure SSL_set_psk_use_session_callback(s:PSSL; cb:TSSL_psk_use_session_cb_func);cdecl;external;
procedure SSL_CTX_set_psk_use_session_callback(ctx:PSSL_CTX; cb:TSSL_psk_use_session_cb_func);cdecl;external;
    { Register callbacks to handle custom TLS Extensions for client or server.  }
(* Const before type ignored *)
function SSL_CTX_has_client_custom_ext(ctx:PSSL_CTX; ext_type:dword):longint;cdecl;external;
function SSL_CTX_add_client_custom_ext(ctx:PSSL_CTX; ext_type:dword; add_cb:Tcustom_ext_add_cb; free_cb:Tcustom_ext_free_cb; add_arg:pointer; 
               parse_cb:Tcustom_ext_parse_cb; parse_arg:pointer):longint;cdecl;external;
function SSL_CTX_add_server_custom_ext(ctx:PSSL_CTX; ext_type:dword; add_cb:Tcustom_ext_add_cb; free_cb:Tcustom_ext_free_cb; add_arg:pointer; 
               parse_cb:Tcustom_ext_parse_cb; parse_arg:pointer):longint;cdecl;external;
function SSL_CTX_add_custom_ext(ctx:PSSL_CTX; ext_type:dword; context:dword; add_cb:TSSL_custom_ext_add_cb_ex; free_cb:TSSL_custom_ext_free_cb_ex; 
               add_arg:pointer; parse_cb:TSSL_custom_ext_parse_cb_ex; parse_arg:pointer):longint;cdecl;external;
function SSL_extension_supported(ext_type:dword):longint;cdecl;external;
    const
      SSL_NOTHING = 1;      
      SSL_WRITING = 2;      
      SSL_READING = 3;      
      SSL_X509_LOOKUP = 4;      
      SSL_ASYNC_PAUSED = 5;      
      SSL_ASYNC_NO_JOBS = 6;      
      SSL_CLIENT_HELLO_CB = 7;      
      SSL_RETRY_VERIFY = 8;      
    { These will only be used when doing non-blocking IO  }
    { was #define dname(params) para_def_expr }
    { argument types are unknown }
    { return type might be wrong }   

    function SSL_want_nothing(s : longint) : longint;    

    { was #define dname(params) para_def_expr }
    { argument types are unknown }
    { return type might be wrong }   
    function SSL_want_read(s : longint) : longint;    

    { was #define dname(params) para_def_expr }
    { argument types are unknown }
    { return type might be wrong }   
    function SSL_want_write(s : longint) : longint;    

    { was #define dname(params) para_def_expr }
    { argument types are unknown }
    { return type might be wrong }   
    function SSL_want_x509_lookup(s : longint) : longint;    

    { was #define dname(params) para_def_expr }
    { argument types are unknown }
    { return type might be wrong }   
    function SSL_want_retry_verify(s : longint) : longint;    

    { was #define dname(params) para_def_expr }
    { argument types are unknown }
    { return type might be wrong }   
    function SSL_want_async(s : longint) : longint;    

    { was #define dname(params) para_def_expr }
    { argument types are unknown }
    { return type might be wrong }   
    function SSL_want_async_job(s : longint) : longint;    

    { was #define dname(params) para_def_expr }
    { argument types are unknown }
    { return type might be wrong }   
    function SSL_want_client_hello_cb(s : longint) : longint;    

    const
      SSL_MAC_FLAG_READ_MAC_STREAM = 1;      
      SSL_MAC_FLAG_WRITE_MAC_STREAM = 2;      
      SSL_MAC_FLAG_READ_MAC_TLSTREE = 4;      
      SSL_MAC_FLAG_WRITE_MAC_TLSTREE = 8;      
    {
     * A callback for logging out TLS key material. This callback should log out
     * |line| followed by a newline.
      }
(* Const before type ignored *)
(* Const before type ignored *)
    type

      TSSL_CTX_keylog_cb_func = procedure (ssl:PSSL; line:Pchar);cdecl;
    {
     * SSL_CTX_set_keylog_callback configures a callback to log key material. This
     * is intended for debugging use with tools like Wireshark. The cb function
     * should log line followed by a newline.
      }

procedure SSL_CTX_set_keylog_callback(ctx:PSSL_CTX; cb:TSSL_CTX_keylog_cb_func);cdecl;external;
    {
     * SSL_CTX_get_keylog_callback returns the callback configured by
     * SSL_CTX_set_keylog_callback.
      }
(* Const before type ignored *)
function SSL_CTX_get_keylog_callback(ctx:PSSL_CTX):TSSL_CTX_keylog_cb_func;cdecl;external;
function SSL_CTX_set_max_early_data(ctx:PSSL_CTX; max_early_data:Tuint32_t):longint;cdecl;external;
(* Const before type ignored *)
function SSL_CTX_get_max_early_data(ctx:PSSL_CTX):Tuint32_t;cdecl;external;
function SSL_set_max_early_data(s:PSSL; max_early_data:Tuint32_t):longint;cdecl;external;
(* Const before type ignored *)
function SSL_get_max_early_data(s:PSSL):Tuint32_t;cdecl;external;
function SSL_CTX_set_recv_max_early_data(ctx:PSSL_CTX; recv_max_early_data:Tuint32_t):longint;cdecl;external;
(* Const before type ignored *)
function SSL_CTX_get_recv_max_early_data(ctx:PSSL_CTX):Tuint32_t;cdecl;external;
function SSL_set_recv_max_early_data(s:PSSL; recv_max_early_data:Tuint32_t):longint;cdecl;external;
(* Const before type ignored *)
function SSL_get_recv_max_early_data(s:PSSL):Tuint32_t;cdecl;external;
{ C++ end of extern C conditionnal removed }
{$include <openssl/ssl2.h>}
{$include <openssl/ssl3.h>}
{$include <openssl/tls1.h>      /* This is mostly sslv3 with a few tweaks */}
{$include <openssl/dtls1.h>     /* Datagram TLS */}
{$include <openssl/srtp.h>      /* Support for the use_srtp extension */}
{ C++ extern C conditionnal removed }
    {
     * These need to be after the above set of includes due to a compiler bug
     * in VisualStudio 2015
      }
    { TLSv1.3 KeyUpdate message types  }
    { -1 used so that this is an invalid value for the on-the-wire protocol  }

    const
      SSL_KEY_UPDATE_NONE = -(1);      
    { Values as defined for the on-the-wire protocol  }
      SSL_KEY_UPDATE_NOT_REQUESTED = 0;      
      SSL_KEY_UPDATE_REQUESTED = 1;      
    {
     * The valid handshake states (one for each type message sent and one for each
     * type of message received). There are also two "special" states:
     * TLS = TLS or DTLS state
     * DTLS = DTLS specific state
     * CR/SR = Client Read/Server Read
     * CW/SW = Client Write/Server Write
     *
     * The "special" states are:
     * TLS_ST_BEFORE = No handshake has been initiated yet
     * TLS_ST_OK = A handshake has been successfully completed
      }
    type
      POSSL_HANDSHAKE_STATE = ^TOSSL_HANDSHAKE_STATE;
      TOSSL_HANDSHAKE_STATE =  Longint;
      Const
        TLS_ST_BEFORE = 0;
        TLS_ST_OK = 1;
        DTLS_ST_CR_HELLO_VERIFY_REQUEST = 2;
        TLS_ST_CR_SRVR_HELLO = 3;
        TLS_ST_CR_CERT = 4;
        TLS_ST_CR_CERT_STATUS = 5;
        TLS_ST_CR_KEY_EXCH = 6;
        TLS_ST_CR_CERT_REQ = 7;
        TLS_ST_CR_SRVR_DONE = 8;
        TLS_ST_CR_SESSION_TICKET = 9;
        TLS_ST_CR_CHANGE = 10;
        TLS_ST_CR_FINISHED = 11;
        TLS_ST_CW_CLNT_HELLO = 12;
        TLS_ST_CW_CERT = 13;
        TLS_ST_CW_KEY_EXCH = 14;
        TLS_ST_CW_CERT_VRFY = 15;
        TLS_ST_CW_CHANGE = 16;
        TLS_ST_CW_NEXT_PROTO = 17;
        TLS_ST_CW_FINISHED = 18;
        TLS_ST_SW_HELLO_REQ = 19;
        TLS_ST_SR_CLNT_HELLO = 20;
        DTLS_ST_SW_HELLO_VERIFY_REQUEST = 21;
        TLS_ST_SW_SRVR_HELLO = 22;
        TLS_ST_SW_CERT = 23;
        TLS_ST_SW_KEY_EXCH = 24;
        TLS_ST_SW_CERT_REQ = 25;
        TLS_ST_SW_SRVR_DONE = 26;
        TLS_ST_SR_CERT = 27;
        TLS_ST_SR_KEY_EXCH = 28;
        TLS_ST_SR_CERT_VRFY = 29;
        TLS_ST_SR_NEXT_PROTO = 30;
        TLS_ST_SR_CHANGE = 31;
        TLS_ST_SR_FINISHED = 32;
        TLS_ST_SW_SESSION_TICKET = 33;
        TLS_ST_SW_CERT_STATUS = 34;
        TLS_ST_SW_CHANGE = 35;
        TLS_ST_SW_FINISHED = 36;
        TLS_ST_SW_ENCRYPTED_EXTENSIONS = 37;
        TLS_ST_CR_ENCRYPTED_EXTENSIONS = 38;
        TLS_ST_CR_CERT_VRFY = 39;
        TLS_ST_SW_CERT_VRFY = 40;
        TLS_ST_CR_HELLO_REQ = 41;
        TLS_ST_SW_KEY_UPDATE = 42;
        TLS_ST_CW_KEY_UPDATE = 43;
        TLS_ST_SR_KEY_UPDATE = 44;
        TLS_ST_CR_KEY_UPDATE = 45;
        TLS_ST_EARLY_DATA = 46;
        TLS_ST_PENDING_EARLY_DATA_END = 47;
        TLS_ST_CW_END_OF_EARLY_DATA = 48;
        TLS_ST_SR_END_OF_EARLY_DATA = 49;
;
    {
     * Most of the following state values are no longer used and are defined to be
     * the closest equivalent value in the current state machine code. Not all
     * defines have an equivalent and are set to a dummy value (-1). SSL_ST_CONNECT
     * and SSL_ST_ACCEPT are still in use in the definition of SSL_CB_ACCEPT_LOOP,
     * SSL_CB_ACCEPT_EXIT, SSL_CB_CONNECT_LOOP and SSL_CB_CONNECT_EXIT.
      }
      SSL_ST_CONNECT = $1000;      
      SSL_ST_ACCEPT = $2000;      
      SSL_ST_MASK = $0FFF;      
      SSL_CB_LOOP = $01;      
      SSL_CB_EXIT = $02;      
      SSL_CB_READ = $04;      
      SSL_CB_WRITE = $08;      
    { used in callback  }
      SSL_CB_ALERT = $4000;      
      SSL_CB_READ_ALERT = SSL_CB_ALERT or SSL_CB_READ;      
      SSL_CB_WRITE_ALERT = SSL_CB_ALERT or SSL_CB_WRITE;      
      SSL_CB_ACCEPT_LOOP = SSL_ST_ACCEPT or SSL_CB_LOOP;      
      SSL_CB_ACCEPT_EXIT = SSL_ST_ACCEPT or SSL_CB_EXIT;      
      SSL_CB_CONNECT_LOOP = SSL_ST_CONNECT or SSL_CB_LOOP;      
      SSL_CB_CONNECT_EXIT = SSL_ST_CONNECT or SSL_CB_EXIT;      
      SSL_CB_HANDSHAKE_START = $10;      
      SSL_CB_HANDSHAKE_DONE = $20;      
    { Is the SSL_connection established?  }
    { was #define dname(params) para_def_expr }
    { argument types are unknown }
    { return type might be wrong }   

    function SSL_in_connect_init(a : longint) : longint;    

    { was #define dname(params) para_def_expr }
    { argument types are unknown }
    { return type might be wrong }   
    function SSL_in_accept_init(a : longint) : longint;    

(* Const before type ignored *)
function SSL_in_init(s:PSSL):longint;cdecl;external;
(* Const before type ignored *)
function SSL_in_before(s:PSSL):longint;cdecl;external;
(* Const before type ignored *)
function SSL_is_init_finished(s:PSSL):longint;cdecl;external;
    {
     * The following 3 states are kept in ssl->rlayer.rstate when reads fail, you
     * should not need these
      }
    const
      SSL_ST_READ_HEADER = $F0;      
      SSL_ST_READ_BODY = $F1;      
      SSL_ST_READ_DONE = $F2;      
    {-
     * Obtain latest Finished message
     *   -- that we sent (SSL_get_finished)
     *   -- that we expected from peer (SSL_get_peer_finished).
     * Returns length (0 == no Finished so far), copies up to 'count' bytes.
      }
(* Const before type ignored *)

function SSL_get_finished(s:PSSL; buf:pointer; count:Tsize_t):Tsize_t;cdecl;external;
(* Const before type ignored *)
function SSL_get_peer_finished(s:PSSL; buf:pointer; count:Tsize_t):Tsize_t;cdecl;external;
    {
     * use either SSL_VERIFY_NONE or SSL_VERIFY_PEER, the last 3 options are
     * 'ored' with SSL_VERIFY_PEER if they are desired
      }
    const
      SSL_VERIFY_NONE = $00;      
      SSL_VERIFY_PEER = $01;      
      SSL_VERIFY_FAIL_IF_NO_PEER_CERT = $02;      
      SSL_VERIFY_CLIENT_ONCE = $04;      
      SSL_VERIFY_POST_HANDSHAKE = $08;      
    { was #define dname(params) para_def_expr }
    { argument types are unknown }
    { return type might be wrong }   

    function d2i_SSL_SESSION_bio(bp,s_id : longint) : longint;    

    { was #define dname(params) para_def_expr }
    { argument types are unknown }
    { return type might be wrong }   
    function i2d_SSL_SESSION_bio(bp,s_id : longint) : longint;    

    {DECLARE_PEM_rw(SSL_SESSION, SSL_SESSION) }
    { offset to get SSL_R_... value
                                                  * from SSL_AD_...  }
    const
      SSL_AD_REASON_OFFSET = 1000;      
    { These alert types are for SSLv3 and TLSv1  }
      SSL_AD_CLOSE_NOTIFY = SSL3_AD_CLOSE_NOTIFY;      
    { fatal  }
      SSL_AD_UNEXPECTED_MESSAGE = SSL3_AD_UNEXPECTED_MESSAGE;      
    { fatal  }
      SSL_AD_BAD_RECORD_MAC = SSL3_AD_BAD_RECORD_MAC;      
      SSL_AD_DECRYPTION_FAILED = TLS1_AD_DECRYPTION_FAILED;      
      SSL_AD_RECORD_OVERFLOW = TLS1_AD_RECORD_OVERFLOW;      
    { fatal  }
      SSL_AD_DECOMPRESSION_FAILURE = SSL3_AD_DECOMPRESSION_FAILURE;      
    { fatal  }
      SSL_AD_HANDSHAKE_FAILURE = SSL3_AD_HANDSHAKE_FAILURE;      
    { Not for TLS  }
      SSL_AD_NO_CERTIFICATE = SSL3_AD_NO_CERTIFICATE;      
      SSL_AD_BAD_CERTIFICATE = SSL3_AD_BAD_CERTIFICATE;      
      SSL_AD_UNSUPPORTED_CERTIFICATE = SSL3_AD_UNSUPPORTED_CERTIFICATE;      
      SSL_AD_CERTIFICATE_REVOKED = SSL3_AD_CERTIFICATE_REVOKED;      
      SSL_AD_CERTIFICATE_EXPIRED = SSL3_AD_CERTIFICATE_EXPIRED;      
      SSL_AD_CERTIFICATE_UNKNOWN = SSL3_AD_CERTIFICATE_UNKNOWN;      
    { fatal  }
      SSL_AD_ILLEGAL_PARAMETER = SSL3_AD_ILLEGAL_PARAMETER;      
    { fatal  }
      SSL_AD_UNKNOWN_CA = TLS1_AD_UNKNOWN_CA;      
    { fatal  }
      SSL_AD_ACCESS_DENIED = TLS1_AD_ACCESS_DENIED;      
    { fatal  }
      SSL_AD_DECODE_ERROR = TLS1_AD_DECODE_ERROR;      
      SSL_AD_DECRYPT_ERROR = TLS1_AD_DECRYPT_ERROR;      
    { fatal  }
      SSL_AD_EXPORT_RESTRICTION = TLS1_AD_EXPORT_RESTRICTION;      
    { fatal  }
      SSL_AD_PROTOCOL_VERSION = TLS1_AD_PROTOCOL_VERSION;      
    { fatal  }
      SSL_AD_INSUFFICIENT_SECURITY = TLS1_AD_INSUFFICIENT_SECURITY;      
    { fatal  }
      SSL_AD_INTERNAL_ERROR = TLS1_AD_INTERNAL_ERROR;      
      SSL_AD_USER_CANCELLED = TLS1_AD_USER_CANCELLED;      
      SSL_AD_NO_RENEGOTIATION = TLS1_AD_NO_RENEGOTIATION;      
      SSL_AD_MISSING_EXTENSION = TLS13_AD_MISSING_EXTENSION;      
      SSL_AD_CERTIFICATE_REQUIRED = TLS13_AD_CERTIFICATE_REQUIRED;      
      SSL_AD_UNSUPPORTED_EXTENSION = TLS1_AD_UNSUPPORTED_EXTENSION;      
      SSL_AD_CERTIFICATE_UNOBTAINABLE = TLS1_AD_CERTIFICATE_UNOBTAINABLE;      
      SSL_AD_UNRECOGNIZED_NAME = TLS1_AD_UNRECOGNIZED_NAME;      
      SSL_AD_BAD_CERTIFICATE_STATUS_RESPONSE = TLS1_AD_BAD_CERTIFICATE_STATUS_RESPONSE;      
      SSL_AD_BAD_CERTIFICATE_HASH_VALUE = TLS1_AD_BAD_CERTIFICATE_HASH_VALUE;      
    { fatal  }
      SSL_AD_UNKNOWN_PSK_IDENTITY = TLS1_AD_UNKNOWN_PSK_IDENTITY;      
    { fatal  }
      SSL_AD_INAPPROPRIATE_FALLBACK = TLS1_AD_INAPPROPRIATE_FALLBACK;      
      SSL_AD_NO_APPLICATION_PROTOCOL = TLS1_AD_NO_APPLICATION_PROTOCOL;      
      SSL_ERROR_NONE = 0;      
      SSL_ERROR_SSL = 1;      
      SSL_ERROR_WANT_READ = 2;      
      SSL_ERROR_WANT_WRITE = 3;      
      SSL_ERROR_WANT_X509_LOOKUP = 4;      
    { look at error stack/return
                                               * value/errno  }
      SSL_ERROR_SYSCALL = 5;      
      SSL_ERROR_ZERO_RETURN = 6;      
      SSL_ERROR_WANT_CONNECT = 7;      
      SSL_ERROR_WANT_ACCEPT = 8;      
      SSL_ERROR_WANT_ASYNC = 9;      
      SSL_ERROR_WANT_ASYNC_JOB = 10;      
      SSL_ERROR_WANT_CLIENT_HELLO_CB = 11;      
      SSL_ERROR_WANT_RETRY_VERIFY = 12;      
      SSL_CTRL_GET_CLIENT_CERT_REQUEST = 9;      
      SSL_CTRL_GET_NUM_RENEGOTIATIONS = 10;      
      SSL_CTRL_CLEAR_NUM_RENEGOTIATIONS = 11;      
      SSL_CTRL_GET_TOTAL_RENEGOTIATIONS = 12;      
      SSL_CTRL_GET_FLAGS = 13;      
      SSL_CTRL_EXTRA_CHAIN_CERT = 14;      
      SSL_CTRL_SET_MSG_CALLBACK = 15;      
      SSL_CTRL_SET_MSG_CALLBACK_ARG = 16;      
    { only applies to datagram connections  }
      SSL_CTRL_SET_MTU = 17;      
    { Stats  }
      SSL_CTRL_SESS_NUMBER = 20;      
      SSL_CTRL_SESS_CONNECT = 21;      
      SSL_CTRL_SESS_CONNECT_GOOD = 22;      
      SSL_CTRL_SESS_CONNECT_RENEGOTIATE = 23;      
      SSL_CTRL_SESS_ACCEPT = 24;      
      SSL_CTRL_SESS_ACCEPT_GOOD = 25;      
      SSL_CTRL_SESS_ACCEPT_RENEGOTIATE = 26;      
      SSL_CTRL_SESS_HIT = 27;      
      SSL_CTRL_SESS_CB_HIT = 28;      
      SSL_CTRL_SESS_MISSES = 29;      
      SSL_CTRL_SESS_TIMEOUTS = 30;      
      SSL_CTRL_SESS_CACHE_FULL = 31;      
      SSL_CTRL_MODE = 33;      
      SSL_CTRL_GET_READ_AHEAD = 40;      
      SSL_CTRL_SET_READ_AHEAD = 41;      
      SSL_CTRL_SET_SESS_CACHE_SIZE = 42;      
      SSL_CTRL_GET_SESS_CACHE_SIZE = 43;      
      SSL_CTRL_SET_SESS_CACHE_MODE = 44;      
      SSL_CTRL_GET_SESS_CACHE_MODE = 45;      
      SSL_CTRL_GET_MAX_CERT_LIST = 50;      
      SSL_CTRL_SET_MAX_CERT_LIST = 51;      
      SSL_CTRL_SET_MAX_SEND_FRAGMENT = 52;      
    { see tls1.h for macros based on these  }
      SSL_CTRL_SET_TLSEXT_SERVERNAME_CB = 53;      
      SSL_CTRL_SET_TLSEXT_SERVERNAME_ARG = 54;      
      SSL_CTRL_SET_TLSEXT_HOSTNAME = 55;      
      SSL_CTRL_SET_TLSEXT_DEBUG_CB = 56;      
      SSL_CTRL_SET_TLSEXT_DEBUG_ARG = 57;      
      SSL_CTRL_GET_TLSEXT_TICKET_KEYS = 58;      
      SSL_CTRL_SET_TLSEXT_TICKET_KEYS = 59;      
    {# define SSL_CTRL_SET_TLSEXT_OPAQUE_PRF_INPUT    60  }
    {# define SSL_CTRL_SET_TLSEXT_OPAQUE_PRF_INPUT_CB 61  }
    {# define SSL_CTRL_SET_TLSEXT_OPAQUE_PRF_INPUT_CB_ARG 62  }
      SSL_CTRL_SET_TLSEXT_STATUS_REQ_CB = 63;      
      SSL_CTRL_SET_TLSEXT_STATUS_REQ_CB_ARG = 64;      
      SSL_CTRL_SET_TLSEXT_STATUS_REQ_TYPE = 65;      
      SSL_CTRL_GET_TLSEXT_STATUS_REQ_EXTS = 66;      
      SSL_CTRL_SET_TLSEXT_STATUS_REQ_EXTS = 67;      
      SSL_CTRL_GET_TLSEXT_STATUS_REQ_IDS = 68;      
      SSL_CTRL_SET_TLSEXT_STATUS_REQ_IDS = 69;      
      SSL_CTRL_GET_TLSEXT_STATUS_REQ_OCSP_RESP = 70;      
      SSL_CTRL_SET_TLSEXT_STATUS_REQ_OCSP_RESP = 71;      
      SSL_CTRL_SET_TLS_EXT_SRP_USERNAME_CB = 75;      
      SSL_CTRL_SET_SRP_VERIFY_PARAM_CB = 76;      
      SSL_CTRL_SET_SRP_GIVE_CLIENT_PWD_CB = 77;      
      SSL_CTRL_SET_SRP_ARG = 78;      
      SSL_CTRL_SET_TLS_EXT_SRP_USERNAME = 79;      
      SSL_CTRL_SET_TLS_EXT_SRP_STRENGTH = 80;      
      SSL_CTRL_SET_TLS_EXT_SRP_PASSWORD = 81;      
      DTLS_CTRL_GET_TIMEOUT = 73;      
      DTLS_CTRL_HANDLE_TIMEOUT = 74;      
      SSL_CTRL_GET_RI_SUPPORT = 76;      
      SSL_CTRL_CLEAR_MODE = 78;      
      SSL_CTRL_SET_NOT_RESUMABLE_SESS_CB = 79;      
      SSL_CTRL_GET_EXTRA_CHAIN_CERTS = 82;      
      SSL_CTRL_CLEAR_EXTRA_CHAIN_CERTS = 83;      
      SSL_CTRL_CHAIN = 88;      
      SSL_CTRL_CHAIN_CERT = 89;      
      SSL_CTRL_GET_GROUPS = 90;      
      SSL_CTRL_SET_GROUPS = 91;      
      SSL_CTRL_SET_GROUPS_LIST = 92;      
      SSL_CTRL_GET_SHARED_GROUP = 93;      
      SSL_CTRL_SET_SIGALGS = 97;      
      SSL_CTRL_SET_SIGALGS_LIST = 98;      
      SSL_CTRL_CERT_FLAGS = 99;      
      SSL_CTRL_CLEAR_CERT_FLAGS = 100;      
      SSL_CTRL_SET_CLIENT_SIGALGS = 101;      
      SSL_CTRL_SET_CLIENT_SIGALGS_LIST = 102;      
      SSL_CTRL_GET_CLIENT_CERT_TYPES = 103;      
      SSL_CTRL_SET_CLIENT_CERT_TYPES = 104;      
      SSL_CTRL_BUILD_CERT_CHAIN = 105;      
      SSL_CTRL_SET_VERIFY_CERT_STORE = 106;      
      SSL_CTRL_SET_CHAIN_CERT_STORE = 107;      
      SSL_CTRL_GET_PEER_SIGNATURE_NID = 108;      
      SSL_CTRL_GET_PEER_TMP_KEY = 109;      
      SSL_CTRL_GET_RAW_CIPHERLIST = 110;      
      SSL_CTRL_GET_EC_POINT_FORMATS = 111;      
      SSL_CTRL_GET_CHAIN_CERTS = 115;      
      SSL_CTRL_SELECT_CURRENT_CERT = 116;      
      SSL_CTRL_SET_CURRENT_CERT = 117;      
      SSL_CTRL_SET_DH_AUTO = 118;      
      DTLS_CTRL_SET_LINK_MTU = 120;      
      DTLS_CTRL_GET_LINK_MIN_MTU = 121;      
      SSL_CTRL_GET_EXTMS_SUPPORT = 122;      
      SSL_CTRL_SET_MIN_PROTO_VERSION = 123;      
      SSL_CTRL_SET_MAX_PROTO_VERSION = 124;      
      SSL_CTRL_SET_SPLIT_SEND_FRAGMENT = 125;      
      SSL_CTRL_SET_MAX_PIPELINES = 126;      
      SSL_CTRL_GET_TLSEXT_STATUS_REQ_TYPE = 127;      
      SSL_CTRL_GET_TLSEXT_STATUS_REQ_CB = 128;      
      SSL_CTRL_GET_TLSEXT_STATUS_REQ_CB_ARG = 129;      
      SSL_CTRL_GET_MIN_PROTO_VERSION = 130;      
      SSL_CTRL_GET_MAX_PROTO_VERSION = 131;      
      SSL_CTRL_GET_SIGNATURE_NID = 132;      
      SSL_CTRL_GET_TMP_KEY = 133;      
      SSL_CTRL_GET_NEGOTIATED_GROUP = 134;      
      SSL_CTRL_SET_RETRY_VERIFY = 136;      
      SSL_CTRL_GET_VERIFY_CERT_STORE = 137;      
      SSL_CTRL_GET_CHAIN_CERT_STORE = 138;      
      SSL_CERT_SET_FIRST = 1;      
      SSL_CERT_SET_NEXT = 2;      
      SSL_CERT_SET_SERVER = 3;      
(* Const before type ignored *)

function SSL_group_to_name(s:PSSL; id:longint):Pchar;cdecl;external;
function SSL_set0_tmp_dh_pkey(s:PSSL; dhpkey:PEVP_PKEY):longint;cdecl;external;
function SSL_CTX_set0_tmp_dh_pkey(ctx:PSSL_CTX; dhpkey:PEVP_PKEY):longint;cdecl;external;
    {
     * The following symbol names are old and obsolete. They are kept
     * for compatibility reasons only and should not be used anymore.
      }
    const
      SSL_CTRL_GET_CURVES = SSL_CTRL_GET_GROUPS;      
      SSL_CTRL_SET_CURVES = SSL_CTRL_SET_GROUPS;      
      SSL_CTRL_SET_CURVES_LIST = SSL_CTRL_SET_GROUPS_LIST;      
      SSL_CTRL_GET_SHARED_CURVE = SSL_CTRL_GET_SHARED_GROUP;      
      SSL_get1_curves = SSL_get1_groups;      
      SSL_CTX_set1_curves = SSL_CTX_set1_groups;      
      SSL_CTX_set1_curves_list = SSL_CTX_set1_groups_list;      
      SSL_set1_curves = SSL_set1_groups;      
      SSL_set1_curves_list = SSL_set1_groups_list;      
      SSL_get_shared_curve = SSL_get_shared_group;      
(* Const before type ignored *)

function BIO_f_ssl:PBIO_METHOD;cdecl;external;
function BIO_new_ssl(ctx:PSSL_CTX; client:longint):PBIO;cdecl;external;
function BIO_new_ssl_connect(ctx:PSSL_CTX):PBIO;cdecl;external;
function BIO_new_buffer_ssl_connect(ctx:PSSL_CTX):PBIO;cdecl;external;
function BIO_ssl_copy_session_id(to:PBIO; from:PBIO):longint;cdecl;external;
procedure BIO_ssl_shutdown(ssl_bio:PBIO);cdecl;external;
(* Const before type ignored *)
function SSL_CTX_set_cipher_list(para1:PSSL_CTX; str:Pchar):longint;cdecl;external;
(* Const before type ignored *)
function SSL_CTX_new(meth:PSSL_METHOD):PSSL_CTX;cdecl;external;
(* Const before type ignored *)
(* Const before type ignored *)
function SSL_CTX_new_ex(libctx:POSSL_LIB_CTX; propq:Pchar; meth:PSSL_METHOD):PSSL_CTX;cdecl;external;
function SSL_CTX_up_ref(ctx:PSSL_CTX):longint;cdecl;external;
procedure SSL_CTX_free(para1:PSSL_CTX);cdecl;external;
function SSL_CTX_set_timeout(ctx:PSSL_CTX; t:longint):longint;cdecl;external;
(* Const before type ignored *)
function SSL_CTX_get_timeout(ctx:PSSL_CTX):longint;cdecl;external;
(* Const before type ignored *)
function SSL_CTX_get_cert_store(para1:PSSL_CTX):PX509_STORE;cdecl;external;
procedure SSL_CTX_set_cert_store(para1:PSSL_CTX; para2:PX509_STORE);cdecl;external;
procedure SSL_CTX_set1_cert_store(para1:PSSL_CTX; para2:PX509_STORE);cdecl;external;
(* Const before type ignored *)
function SSL_want(s:PSSL):longint;cdecl;external;
function SSL_clear(s:PSSL):longint;cdecl;external;
procedure SSL_CTX_flush_sessions(ctx:PSSL_CTX; tm:longint);cdecl;external;
(* Const before type ignored *)
(* Const before type ignored *)
function SSL_get_current_cipher(s:PSSL):PSSL_CIPHER;cdecl;external;
(* Const before type ignored *)
(* Const before type ignored *)
function SSL_get_pending_cipher(s:PSSL):PSSL_CIPHER;cdecl;external;
(* Const before type ignored *)
function SSL_CIPHER_get_bits(c:PSSL_CIPHER; alg_bits:Plongint):longint;cdecl;external;
(* Const before type ignored *)
(* Const before type ignored *)
function SSL_CIPHER_get_version(c:PSSL_CIPHER):Pchar;cdecl;external;
(* Const before type ignored *)
(* Const before type ignored *)
function SSL_CIPHER_get_name(c:PSSL_CIPHER):Pchar;cdecl;external;
(* Const before type ignored *)
(* Const before type ignored *)
function SSL_CIPHER_standard_name(c:PSSL_CIPHER):Pchar;cdecl;external;
(* Const before type ignored *)
(* Const before type ignored *)
function OPENSSL_cipher_name(rfc_name:Pchar):Pchar;cdecl;external;
(* Const before type ignored *)
function SSL_CIPHER_get_id(c:PSSL_CIPHER):Tuint32_t;cdecl;external;
(* Const before type ignored *)
function SSL_CIPHER_get_protocol_id(c:PSSL_CIPHER):Tuint16_t;cdecl;external;
(* Const before type ignored *)
function SSL_CIPHER_get_kx_nid(c:PSSL_CIPHER):longint;cdecl;external;
(* Const before type ignored *)
function SSL_CIPHER_get_auth_nid(c:PSSL_CIPHER):longint;cdecl;external;
(* Const before type ignored *)
(* Const before type ignored *)
function SSL_CIPHER_get_handshake_digest(c:PSSL_CIPHER):PEVP_MD;cdecl;external;
(* Const before type ignored *)
function SSL_CIPHER_is_aead(c:PSSL_CIPHER):longint;cdecl;external;
(* Const before type ignored *)
function SSL_get_fd(s:PSSL):longint;cdecl;external;
(* Const before type ignored *)
function SSL_get_rfd(s:PSSL):longint;cdecl;external;
(* Const before type ignored *)
function SSL_get_wfd(s:PSSL):longint;cdecl;external;
(* Const before type ignored *)
(* Const before type ignored *)
function SSL_get_cipher_list(s:PSSL; n:longint):Pchar;cdecl;external;
(* Const before type ignored *)
function SSL_get_shared_ciphers(s:PSSL; buf:Pchar; size:longint):Pchar;cdecl;external;
(* Const before type ignored *)
function SSL_get_read_ahead(s:PSSL):longint;cdecl;external;
(* Const before type ignored *)
function SSL_pending(s:PSSL):longint;cdecl;external;
(* Const before type ignored *)
function SSL_has_pending(s:PSSL):longint;cdecl;external;
{$ifndef OPENSSL_NO_SOCK}

function SSL_set_fd(s:PSSL; fd:longint):longint;cdecl;external;
function SSL_set_rfd(s:PSSL; fd:longint):longint;cdecl;external;
function SSL_set_wfd(s:PSSL; fd:longint):longint;cdecl;external;
{$endif}

procedure SSL_set0_rbio(s:PSSL; rbio:PBIO);cdecl;external;
procedure SSL_set0_wbio(s:PSSL; wbio:PBIO);cdecl;external;
procedure SSL_set_bio(s:PSSL; rbio:PBIO; wbio:PBIO);cdecl;external;
(* Const before type ignored *)
function SSL_get_rbio(s:PSSL):PBIO;cdecl;external;
(* Const before type ignored *)
function SSL_get_wbio(s:PSSL):PBIO;cdecl;external;
(* Const before type ignored *)
function SSL_set_cipher_list(s:PSSL; str:Pchar):longint;cdecl;external;
(* Const before type ignored *)
function SSL_CTX_set_ciphersuites(ctx:PSSL_CTX; str:Pchar):longint;cdecl;external;
(* Const before type ignored *)
function SSL_set_ciphersuites(s:PSSL; str:Pchar):longint;cdecl;external;
procedure SSL_set_read_ahead(s:PSSL; yes:longint);cdecl;external;
(* Const before type ignored *)
function SSL_get_verify_mode(s:PSSL):longint;cdecl;external;
(* Const before type ignored *)
function SSL_get_verify_depth(s:PSSL):longint;cdecl;external;
(* Const before type ignored *)
function SSL_get_verify_callback(s:PSSL):TSSL_verify_cb;cdecl;external;
procedure SSL_set_verify(s:PSSL; mode:longint; callback:TSSL_verify_cb);cdecl;external;
procedure SSL_set_verify_depth(s:PSSL; depth:longint);cdecl;external;
procedure SSL_set_cert_cb(s:PSSL; cb:function (ssl:PSSL; arg:pointer):longint; arg:pointer);cdecl;external;
function SSL_use_PrivateKey(ssl:PSSL; pkey:PEVP_PKEY):longint;cdecl;external;
(* Const before type ignored *)
function SSL_use_PrivateKey_ASN1(pk:longint; ssl:PSSL; d:Pbyte; len:longint):longint;cdecl;external;
function SSL_use_certificate(ssl:PSSL; x:PX509):longint;cdecl;external;
(* Const before type ignored *)
function SSL_use_certificate_ASN1(ssl:PSSL; d:Pbyte; len:longint):longint;cdecl;external;
(* error 
                                STACK_OF(X509) *chain, int override);
(* error 
                                STACK_OF(X509) *chain, int override);
 in declarator_list *)
 in declarator_list *)
    { serverinfo file format versions  }
    const
      SSL_SERVERINFOV1 = 1;      
      SSL_SERVERINFOV2 = 2;      
    { Set serverinfo data for the current active cert.  }
(* Const before type ignored *)

function SSL_CTX_use_serverinfo(ctx:PSSL_CTX; serverinfo:Pbyte; serverinfo_length:Tsize_t):longint;cdecl;external;
(* Const before type ignored *)
function SSL_CTX_use_serverinfo_ex(ctx:PSSL_CTX; version:dword; serverinfo:Pbyte; serverinfo_length:Tsize_t):longint;cdecl;external;
(* Const before type ignored *)
function SSL_CTX_use_serverinfo_file(ctx:PSSL_CTX; file:Pchar):longint;cdecl;external;
(* Const before type ignored *)
function SSL_use_PrivateKey_file(ssl:PSSL; file:Pchar; _type:longint):longint;cdecl;external;
(* Const before type ignored *)
function SSL_use_certificate_file(ssl:PSSL; file:Pchar; _type:longint):longint;cdecl;external;
(* Const before type ignored *)
function SSL_CTX_use_PrivateKey_file(ctx:PSSL_CTX; file:Pchar; _type:longint):longint;cdecl;external;
(* Const before type ignored *)
function SSL_CTX_use_certificate_file(ctx:PSSL_CTX; file:Pchar; _type:longint):longint;cdecl;external;
    { PEM type  }
(* Const before type ignored *)
function SSL_CTX_use_certificate_chain_file(ctx:PSSL_CTX; file:Pchar):longint;cdecl;external;
(* Const before type ignored *)
function SSL_use_certificate_chain_file(ssl:PSSL; file:Pchar):longint;cdecl;external;
(* error 
 STACK_OF(X509_NAME) *SSL_load_client_CA_file(const char *file);
 in declarator_list *)
(* error 
*SSL_load_client_CA_file_ex(const char *file, OSSL_LIB_CTX *libctx,
(* error 
*SSL_load_client_CA_file_ex(const char *file, OSSL_LIB_CTX *libctx,
(* error 
                            const char *propq);
 in declarator_list *)
 in declarator_list *)
 in declarator_list *)
(* error 
 int SSL_add_file_cert_subjects_to_stack(STACK_OF(X509_NAME) *stackCAs,
(* error 
                                               const char *file);
 in declarator_list *)
 in declarator_list *)
(* error 
int SSL_add_dir_cert_subjects_to_stack(STACK_OF(X509_NAME) *stackCAs,
(* error 
                                       const char *dir);
 in declarator_list *)
 in declarator_list *)
(* error 
int SSL_add_store_cert_subjects_to_stack(STACK_OF(X509_NAME) *stackCAs,
(* error 
                                       const char *uri);
 in declarator_list *)
 in declarator_list *)
(* Const before type ignored *)
(* Const before type ignored *)
function SSL_state_string(s:PSSL):Pchar;cdecl;external;
(* Const before type ignored *)
(* Const before type ignored *)
function SSL_rstate_string(s:PSSL):Pchar;cdecl;external;
(* Const before type ignored *)
(* Const before type ignored *)
function SSL_state_string_long(s:PSSL):Pchar;cdecl;external;
(* Const before type ignored *)
(* Const before type ignored *)
function SSL_rstate_string_long(s:PSSL):Pchar;cdecl;external;
(* Const before type ignored *)
function SSL_SESSION_get_time(s:PSSL_SESSION):longint;cdecl;external;
function SSL_SESSION_set_time(s:PSSL_SESSION; t:longint):longint;cdecl;external;
(* Const before type ignored *)
function SSL_SESSION_get_timeout(s:PSSL_SESSION):longint;cdecl;external;
function SSL_SESSION_set_timeout(s:PSSL_SESSION; t:longint):longint;cdecl;external;
(* Const before type ignored *)
function SSL_SESSION_get_protocol_version(s:PSSL_SESSION):longint;cdecl;external;
function SSL_SESSION_set_protocol_version(s:PSSL_SESSION; version:longint):longint;cdecl;external;
(* Const before type ignored *)
(* Const before type ignored *)
function SSL_SESSION_get0_hostname(s:PSSL_SESSION):Pchar;cdecl;external;
(* Const before type ignored *)
function SSL_SESSION_set1_hostname(s:PSSL_SESSION; hostname:Pchar):longint;cdecl;external;
(* Const before type ignored *)
(* Const before type ignored *)
procedure SSL_SESSION_get0_alpn_selected(s:PSSL_SESSION; alpn:PPbyte; len:Psize_t);cdecl;external;
(* Const before type ignored *)
function SSL_SESSION_set1_alpn_selected(s:PSSL_SESSION; alpn:Pbyte; len:Tsize_t):longint;cdecl;external;
(* Const before type ignored *)
(* Const before type ignored *)
function SSL_SESSION_get0_cipher(s:PSSL_SESSION):PSSL_CIPHER;cdecl;external;
(* Const before type ignored *)
function SSL_SESSION_set_cipher(s:PSSL_SESSION; cipher:PSSL_CIPHER):longint;cdecl;external;
(* Const before type ignored *)
function SSL_SESSION_has_ticket(s:PSSL_SESSION):longint;cdecl;external;
(* Const before type ignored *)
function SSL_SESSION_get_ticket_lifetime_hint(s:PSSL_SESSION):dword;cdecl;external;
(* Const before type ignored *)
(* Const before type ignored *)
procedure SSL_SESSION_get0_ticket(s:PSSL_SESSION; tick:PPbyte; len:Psize_t);cdecl;external;
(* Const before type ignored *)
function SSL_SESSION_get_max_early_data(s:PSSL_SESSION):Tuint32_t;cdecl;external;
function SSL_SESSION_set_max_early_data(s:PSSL_SESSION; max_early_data:Tuint32_t):longint;cdecl;external;
(* Const before type ignored *)
function SSL_copy_session_id(to:PSSL; from:PSSL):longint;cdecl;external;
function SSL_SESSION_get0_peer(s:PSSL_SESSION):PX509;cdecl;external;
(* Const before type ignored *)
function SSL_SESSION_set1_id_context(s:PSSL_SESSION; sid_ctx:Pbyte; sid_ctx_len:dword):longint;cdecl;external;
(* Const before type ignored *)
function SSL_SESSION_set1_id(s:PSSL_SESSION; sid:Pbyte; sid_len:dword):longint;cdecl;external;
(* Const before type ignored *)
function SSL_SESSION_is_resumable(s:PSSL_SESSION):longint;cdecl;external;
function SSL_SESSION_new:PSSL_SESSION;cdecl;external;
(* Const before type ignored *)
function SSL_SESSION_dup(src:PSSL_SESSION):PSSL_SESSION;cdecl;external;
(* Const before type ignored *)
(* Const before type ignored *)
function SSL_SESSION_get_id(s:PSSL_SESSION; len:Pdword):Pbyte;cdecl;external;
(* Const before type ignored *)
(* Const before type ignored *)
function SSL_SESSION_get0_id_context(s:PSSL_SESSION; len:Pdword):Pbyte;cdecl;external;
(* Const before type ignored *)
function SSL_SESSION_get_compress_id(s:PSSL_SESSION):dword;cdecl;external;
{$ifndef OPENSSL_NO_STDIO}
(* Const before type ignored *)

function SSL_SESSION_print_fp(fp:PFILE; ses:PSSL_SESSION):longint;cdecl;external;
{$endif}
(* Const before type ignored *)

function SSL_SESSION_print(fp:PBIO; ses:PSSL_SESSION):longint;cdecl;external;
(* Const before type ignored *)
function SSL_SESSION_print_keylog(bp:PBIO; x:PSSL_SESSION):longint;cdecl;external;
function SSL_SESSION_up_ref(ses:PSSL_SESSION):longint;cdecl;external;
procedure SSL_SESSION_free(ses:PSSL_SESSION);cdecl;external;
(* Const before type ignored *)
function i2d_SSL_SESSION(in:PSSL_SESSION; pp:PPbyte):longint;cdecl;external;
function SSL_set_session(to:PSSL; session:PSSL_SESSION):longint;cdecl;external;
function SSL_CTX_add_session(ctx:PSSL_CTX; session:PSSL_SESSION):longint;cdecl;external;
function SSL_CTX_remove_session(ctx:PSSL_CTX; session:PSSL_SESSION):longint;cdecl;external;
function SSL_CTX_set_generate_session_id(ctx:PSSL_CTX; cb:TGEN_SESSION_CB):longint;cdecl;external;
function SSL_set_generate_session_id(s:PSSL; cb:TGEN_SESSION_CB):longint;cdecl;external;
(* Const before type ignored *)
(* Const before type ignored *)
function SSL_has_matching_session_id(s:PSSL; id:Pbyte; id_len:dword):longint;cdecl;external;
(* Const before type ignored *)
function d2i_SSL_SESSION(a:PPSSL_SESSION; pp:PPbyte; length:longint):PSSL_SESSION;cdecl;external;
{$ifdef OPENSSL_X509_H}
(* Const before type ignored *)

function SSL_get0_peer_certificate(s:PSSL):PX509;cdecl;external;
(* Const before type ignored *)
function SSL_get1_peer_certificate(s:PSSL):PX509;cdecl;external;
{$endif}
(* error 
 STACK_OF(X509) *SSL_get_peer_cert_chain(const SSL *s);
 in declarator_list *)
(* Const before type ignored *)

function SSL_CTX_get_verify_mode(ctx:PSSL_CTX):longint;cdecl;external;
(* Const before type ignored *)
function SSL_CTX_get_verify_depth(ctx:PSSL_CTX):longint;cdecl;external;
(* Const before type ignored *)
function SSL_CTX_get_verify_callback(ctx:PSSL_CTX):TSSL_verify_cb;cdecl;external;
procedure SSL_CTX_set_verify(ctx:PSSL_CTX; mode:longint; callback:TSSL_verify_cb);cdecl;external;
procedure SSL_CTX_set_verify_depth(ctx:PSSL_CTX; depth:longint);cdecl;external;
procedure SSL_CTX_set_cert_verify_callback(ctx:PSSL_CTX; cb:function (para1:PX509_STORE_CTX; para2:pointer):longint; arg:pointer);cdecl;external;
procedure SSL_CTX_set_cert_cb(c:PSSL_CTX; cb:function (ssl:PSSL; arg:pointer):longint; arg:pointer);cdecl;external;
function SSL_CTX_use_PrivateKey(ctx:PSSL_CTX; pkey:PEVP_PKEY):longint;cdecl;external;
(* Const before type ignored *)
function SSL_CTX_use_PrivateKey_ASN1(pk:longint; ctx:PSSL_CTX; d:Pbyte; len:longint):longint;cdecl;external;
function SSL_CTX_use_certificate(ctx:PSSL_CTX; x:PX509):longint;cdecl;external;
(* Const before type ignored *)
function SSL_CTX_use_certificate_ASN1(ctx:PSSL_CTX; len:longint; d:Pbyte):longint;cdecl;external;
(* error 
                                    STACK_OF(X509) *chain, int override);
(* error 
                                    STACK_OF(X509) *chain, int override);
 in declarator_list *)
 in declarator_list *)
procedure SSL_CTX_set_default_passwd_cb(ctx:PSSL_CTX; cb:Ppem_password_cb);cdecl;external;
procedure SSL_CTX_set_default_passwd_cb_userdata(ctx:PSSL_CTX; u:pointer);cdecl;external;
function SSL_CTX_get_default_passwd_cb(ctx:PSSL_CTX):Ppem_password_cb;cdecl;external;
function SSL_CTX_get_default_passwd_cb_userdata(ctx:PSSL_CTX):pointer;cdecl;external;
procedure SSL_set_default_passwd_cb(s:PSSL; cb:Ppem_password_cb);cdecl;external;
procedure SSL_set_default_passwd_cb_userdata(s:PSSL; u:pointer);cdecl;external;
function SSL_get_default_passwd_cb(s:PSSL):Ppem_password_cb;cdecl;external;
function SSL_get_default_passwd_cb_userdata(s:PSSL):pointer;cdecl;external;
(* Const before type ignored *)
function SSL_CTX_check_private_key(ctx:PSSL_CTX):longint;cdecl;external;
(* Const before type ignored *)
function SSL_check_private_key(ctx:PSSL):longint;cdecl;external;
(* Const before type ignored *)
function SSL_CTX_set_session_id_context(ctx:PSSL_CTX; sid_ctx:Pbyte; sid_ctx_len:dword):longint;cdecl;external;
function SSL_new(ctx:PSSL_CTX):PSSL;cdecl;external;
function SSL_up_ref(s:PSSL):longint;cdecl;external;
(* Const before type ignored *)
function SSL_is_dtls(s:PSSL):longint;cdecl;external;
(* Const before type ignored *)
function SSL_set_session_id_context(ssl:PSSL; sid_ctx:Pbyte; sid_ctx_len:dword):longint;cdecl;external;
function SSL_CTX_set_purpose(ctx:PSSL_CTX; purpose:longint):longint;cdecl;external;
function SSL_set_purpose(ssl:PSSL; purpose:longint):longint;cdecl;external;
function SSL_CTX_set_trust(ctx:PSSL_CTX; trust:longint):longint;cdecl;external;
function SSL_set_trust(ssl:PSSL; trust:longint):longint;cdecl;external;
(* Const before type ignored *)
function SSL_set1_host(s:PSSL; hostname:Pchar):longint;cdecl;external;
(* Const before type ignored *)
function SSL_add1_host(s:PSSL; hostname:Pchar):longint;cdecl;external;
(* Const before type ignored *)
function SSL_get0_peername(s:PSSL):Pchar;cdecl;external;
procedure SSL_set_hostflags(s:PSSL; flags:dword);cdecl;external;
function SSL_CTX_dane_enable(ctx:PSSL_CTX):longint;cdecl;external;
(* Const before type ignored *)
function SSL_CTX_dane_mtype_set(ctx:PSSL_CTX; md:PEVP_MD; mtype:Tuint8_t; ord:Tuint8_t):longint;cdecl;external;
(* Const before type ignored *)
function SSL_dane_enable(s:PSSL; basedomain:Pchar):longint;cdecl;external;
(* Const before type ignored *)
function SSL_dane_tlsa_add(s:PSSL; usage:Tuint8_t; selector:Tuint8_t; mtype:Tuint8_t; data:Pbyte; 
               dlen:Tsize_t):longint;cdecl;external;
function SSL_get0_dane_authority(s:PSSL; mcert:PPX509; mspki:PPEVP_PKEY):longint;cdecl;external;
(* Const before type ignored *)
function SSL_get0_dane_tlsa(s:PSSL; usage:Puint8_t; selector:Puint8_t; mtype:Puint8_t; data:PPbyte; 
               dlen:Psize_t):longint;cdecl;external;
    {
     * Bridge opacity barrier between libcrypt and libssl, also needed to support
     * offline testing in test/danetest.c
      }
function SSL_get0_dane(ssl:PSSL):PSSL_DANE;cdecl;external;
    {
     * DANE flags
      }
function SSL_CTX_dane_set_flags(ctx:PSSL_CTX; flags:dword):dword;cdecl;external;
function SSL_CTX_dane_clear_flags(ctx:PSSL_CTX; flags:dword):dword;cdecl;external;
function SSL_dane_set_flags(ssl:PSSL; flags:dword):dword;cdecl;external;
function SSL_dane_clear_flags(ssl:PSSL; flags:dword):dword;cdecl;external;
function SSL_CTX_set1_param(ctx:PSSL_CTX; vpm:PX509_VERIFY_PARAM):longint;cdecl;external;
function SSL_set1_param(ssl:PSSL; vpm:PX509_VERIFY_PARAM):longint;cdecl;external;
function SSL_CTX_get0_param(ctx:PSSL_CTX):PX509_VERIFY_PARAM;cdecl;external;
function SSL_get0_param(ssl:PSSL):PX509_VERIFY_PARAM;cdecl;external;
    {
     * ClientHello callback and helpers.
      }
    const
      SSL_CLIENT_HELLO_SUCCESS = 1;      
      SSL_CLIENT_HELLO_ERROR = 0;      
      SSL_CLIENT_HELLO_RETRY = -(1);      
    type

      TSSL_client_hello_cb_fn = function (s:PSSL; al:Plongint; arg:pointer):longint;cdecl;

procedure SSL_CTX_set_client_hello_cb(c:PSSL_CTX; cb:TSSL_client_hello_cb_fn; arg:pointer);cdecl;external;
function SSL_client_hello_isv2(s:PSSL):longint;cdecl;external;
function SSL_client_hello_get0_legacy_version(s:PSSL):dword;cdecl;external;
(* Const before type ignored *)
function SSL_client_hello_get0_random(s:PSSL; out:PPbyte):Tsize_t;cdecl;external;
(* Const before type ignored *)
function SSL_client_hello_get0_session_id(s:PSSL; out:PPbyte):Tsize_t;cdecl;external;
(* Const before type ignored *)
function SSL_client_hello_get0_ciphers(s:PSSL; out:PPbyte):Tsize_t;cdecl;external;
(* Const before type ignored *)
function SSL_client_hello_get0_compression_methods(s:PSSL; out:PPbyte):Tsize_t;cdecl;external;
function SSL_client_hello_get1_extensions_present(s:PSSL; out:PPlongint; outlen:Psize_t):longint;cdecl;external;
(* Const before type ignored *)
function SSL_client_hello_get0_ext(s:PSSL; _type:dword; out:PPbyte; outlen:Psize_t):longint;cdecl;external;
procedure SSL_certs_clear(s:PSSL);cdecl;external;
procedure SSL_free(ssl:PSSL);cdecl;external;
{$ifdef OSSL_ASYNC_FD}
    {
     * Windows application developer has to include windows.h to use these.
      }

function SSL_waiting_for_async(s:PSSL):longint;cdecl;external;
function SSL_get_all_async_fds(s:PSSL; fds:POSSL_ASYNC_FD; numfds:Psize_t):longint;cdecl;external;
function SSL_get_changed_async_fds(s:PSSL; addfd:POSSL_ASYNC_FD; numaddfds:Psize_t; delfd:POSSL_ASYNC_FD; numdelfds:Psize_t):longint;cdecl;external;
function SSL_CTX_set_async_callback(ctx:PSSL_CTX; callback:TSSL_async_callback_fn):longint;cdecl;external;
function SSL_CTX_set_async_callback_arg(ctx:PSSL_CTX; arg:pointer):longint;cdecl;external;
function SSL_set_async_callback(s:PSSL; callback:TSSL_async_callback_fn):longint;cdecl;external;
function SSL_set_async_callback_arg(s:PSSL; arg:pointer):longint;cdecl;external;
function SSL_get_async_status(s:PSSL; status:Plongint):longint;cdecl;external;
{$endif}

function SSL_accept(ssl:PSSL):longint;cdecl;external;
function SSL_stateless(s:PSSL):longint;cdecl;external;
function SSL_connect(ssl:PSSL):longint;cdecl;external;
function SSL_read(ssl:PSSL; buf:pointer; num:longint):longint;cdecl;external;
function SSL_read_ex(ssl:PSSL; buf:pointer; num:Tsize_t; readbytes:Psize_t):longint;cdecl;external;
    const
      SSL_READ_EARLY_DATA_ERROR = 0;      
      SSL_READ_EARLY_DATA_SUCCESS = 1;      
      SSL_READ_EARLY_DATA_FINISH = 2;      

function SSL_read_early_data(s:PSSL; buf:pointer; num:Tsize_t; readbytes:Psize_t):longint;cdecl;external;
function SSL_peek(ssl:PSSL; buf:pointer; num:longint):longint;cdecl;external;
function SSL_peek_ex(ssl:PSSL; buf:pointer; num:Tsize_t; readbytes:Psize_t):longint;cdecl;external;
function SSL_sendfile(s:PSSL; fd:longint; offset:Toff_t; size:Tsize_t; flags:longint):Tossl_ssize_t;cdecl;external;
(* Const before type ignored *)
function SSL_write(ssl:PSSL; buf:pointer; num:longint):longint;cdecl;external;
(* Const before type ignored *)
function SSL_write_ex(s:PSSL; buf:pointer; num:Tsize_t; written:Psize_t):longint;cdecl;external;
(* Const before type ignored *)
function SSL_write_early_data(s:PSSL; buf:pointer; num:Tsize_t; written:Psize_t):longint;cdecl;external;
function SSL_ctrl(ssl:PSSL; cmd:longint; larg:longint; parg:pointer):longint;cdecl;external;
function SSL_callback_ctrl(para1:PSSL; para2:longint; para3:procedure ):longint;cdecl;external;
function SSL_CTX_ctrl(ctx:PSSL_CTX; cmd:longint; larg:longint; parg:pointer):longint;cdecl;external;
function SSL_CTX_callback_ctrl(para1:PSSL_CTX; para2:longint; para3:procedure ):longint;cdecl;external;
    const
      SSL_EARLY_DATA_NOT_SENT = 0;      
      SSL_EARLY_DATA_REJECTED = 1;      
      SSL_EARLY_DATA_ACCEPTED = 2;      
(* Const before type ignored *)

function SSL_get_early_data_status(s:PSSL):longint;cdecl;external;
(* Const before type ignored *)
function SSL_get_error(s:PSSL; ret_code:longint):longint;cdecl;external;
(* Const before type ignored *)
(* Const before type ignored *)
function SSL_get_version(s:PSSL):Pchar;cdecl;external;
    { This sets the 'default' SSL version that SSL_new() will create  }
    const
      SSLv23_method = TLS_method;      
      SSLv23_server_method = TLS_server_method;      
      SSLv23_client_method = TLS_client_method;      
    { Negotiate highest available SSL/TLS version  }
(* Const before type ignored *)

function TLS_method:PSSL_METHOD;cdecl;external;
(* Const before type ignored *)
function TLS_server_method:PSSL_METHOD;cdecl;external;
(* Const before type ignored *)
function TLS_client_method:PSSL_METHOD;cdecl;external;
(* Const before type ignored *)
function DTLS_method:PSSL_METHOD;cdecl;external;
    { DTLS 1.0 and 1.2  }
(* Const before type ignored *)
function DTLS_server_method:PSSL_METHOD;cdecl;external;
    { DTLS 1.0 and 1.2  }
(* Const before type ignored *)
function DTLS_client_method:PSSL_METHOD;cdecl;external;
    { DTLS 1.0 and 1.2  }
(* Const before type ignored *)
function DTLS_get_data_mtu(s:PSSL):Tsize_t;cdecl;external;
(* Const before type ignored *)
function SSL_get_ciphers(s:PSSL):Pstack_st_SSL_CIPHERtype;cdecl;external;
(* Const before type ignored *)
function SSL_CTX_get_ciphers(ctx:PSSL_CTX):Pstack_st_SSL_CIPHERtype;cdecl;external;
(* Const before type ignored *)
function SSL_get_client_ciphers(s:PSSL):Pstack_st_SSL_CIPHERtype;cdecl;external;
function SSL_get1_supported_ciphers(s:PSSL):Pstack_st_SSL_CIPHERtype;cdecl;external;
function SSL_do_handshake(s:PSSL):longint;cdecl;external;
function SSL_key_update(s:PSSL; updatetype:longint):longint;cdecl;external;
(* Const before type ignored *)
function SSL_get_key_update_type(s:PSSL):longint;cdecl;external;
function SSL_renegotiate(s:PSSL):longint;cdecl;external;
function SSL_renegotiate_abbreviated(s:PSSL):longint;cdecl;external;
(* Const before type ignored *)
function SSL_renegotiate_pending(s:PSSL):longint;cdecl;external;
function SSL_new_session_ticket(s:PSSL):longint;cdecl;external;
function SSL_shutdown(s:PSSL):longint;cdecl;external;
function SSL_verify_client_post_handshake(s:PSSL):longint;cdecl;external;
procedure SSL_CTX_set_post_handshake_auth(ctx:PSSL_CTX; val:longint);cdecl;external;
procedure SSL_set_post_handshake_auth(s:PSSL; val:longint);cdecl;external;
(* Const before type ignored *)
(* Const before type ignored *)
function SSL_CTX_get_ssl_method(ctx:PSSL_CTX):PSSL_METHOD;cdecl;external;
(* Const before type ignored *)
(* Const before type ignored *)
function SSL_get_ssl_method(s:PSSL):PSSL_METHOD;cdecl;external;
(* Const before type ignored *)
function SSL_set_ssl_method(s:PSSL; method:PSSL_METHOD):longint;cdecl;external;
(* Const before type ignored *)
function SSL_alert_type_string_long(value:longint):Pchar;cdecl;external;
(* Const before type ignored *)
function SSL_alert_type_string(value:longint):Pchar;cdecl;external;
(* Const before type ignored *)
function SSL_alert_desc_string_long(value:longint):Pchar;cdecl;external;
(* Const before type ignored *)
function SSL_alert_desc_string(value:longint):Pchar;cdecl;external;
(* error 
void SSL_set0_CA_list(SSL *s, STACK_OF(X509_NAME) *name_list);
 in declarator_list *)
(* error 
void SSL_CTX_set0_CA_list(SSL_CTX *ctx, STACK_OF(X509_NAME) *name_list);
 in declarator_list *)
(* Const before type ignored *)
(* error 
 const STACK_OF(X509_NAME) *SSL_get0_CA_list(const SSL *s);
 in declarator_list *)
(* Const before type ignored *)
(* error 
 const STACK_OF(X509_NAME) *SSL_CTX_get0_CA_list(const SSL_CTX *ctx);
 in declarator_list *)
(* Const before type ignored *)
function SSL_add1_to_CA_list(ssl:PSSL; x:PX509):longint;cdecl;external;
(* Const before type ignored *)
function SSL_CTX_add1_to_CA_list(ctx:PSSL_CTX; x:PX509):longint;cdecl;external;
(* Const before type ignored *)
(* error 
 const STACK_OF(X509_NAME) *SSL_get0_peer_CA_list(const SSL *s);
 in declarator_list *)
(* error 
void SSL_set_client_CA_list(SSL *s, STACK_OF(X509_NAME) *name_list);
 in declarator_list *)
(* error 
void SSL_CTX_set_client_CA_list(SSL_CTX *ctx, STACK_OF(X509_NAME) *name_list);
 in declarator_list *)
(* error 
 STACK_OF(X509_NAME) *SSL_get_client_CA_list(const SSL *s);
 in declarator_list *)
(* error 
 STACK_OF(X509_NAME) *SSL_CTX_get_client_CA_list(const SSL_CTX *s);
 in declarator_list *)
function SSL_add_client_CA(ssl:PSSL; x:PX509):longint;cdecl;external;
function SSL_CTX_add_client_CA(ctx:PSSL_CTX; x:PX509):longint;cdecl;external;
procedure SSL_set_connect_state(s:PSSL);cdecl;external;
procedure SSL_set_accept_state(s:PSSL);cdecl;external;
(* Const before type ignored *)
function SSL_get_default_timeout(s:PSSL):longint;cdecl;external;
(* Const before type ignored *)
function SSL_CIPHER_description(para1:PSSL_CIPHER; buf:Pchar; size:longint):Pchar;cdecl;external;
(* error 
 STACK_OF(X509_NAME) *SSL_dup_CA_list(const STACK_OF(X509_NAME) *sk);
 in declarator_list *)
function SSL_dup(ssl:PSSL):PSSL;cdecl;external;
(* Const before type ignored *)
function SSL_get_certificate(ssl:PSSL):PX509;cdecl;external;
    {
     * EVP_PKEY
      }
(* error 
struct evp_pkey_st *SSL_get_privatekey(const SSL *ssl);
in declaration at line 1596 *)
(* Const before type ignored *)
function SSL_CTX_get0_certificate(ctx:PSSL_CTX):PX509;cdecl;external;
(* Const before type ignored *)
function SSL_CTX_get0_privatekey(ctx:PSSL_CTX):PEVP_PKEY;cdecl;external;
procedure SSL_CTX_set_quiet_shutdown(ctx:PSSL_CTX; mode:longint);cdecl;external;
(* Const before type ignored *)
function SSL_CTX_get_quiet_shutdown(ctx:PSSL_CTX):longint;cdecl;external;
procedure SSL_set_quiet_shutdown(ssl:PSSL; mode:longint);cdecl;external;
(* Const before type ignored *)
function SSL_get_quiet_shutdown(ssl:PSSL):longint;cdecl;external;
procedure SSL_set_shutdown(ssl:PSSL; mode:longint);cdecl;external;
(* Const before type ignored *)
function SSL_get_shutdown(ssl:PSSL):longint;cdecl;external;
(* Const before type ignored *)
function SSL_version(ssl:PSSL):longint;cdecl;external;
(* Const before type ignored *)
function SSL_client_version(s:PSSL):longint;cdecl;external;
function SSL_CTX_set_default_verify_paths(ctx:PSSL_CTX):longint;cdecl;external;
function SSL_CTX_set_default_verify_dir(ctx:PSSL_CTX):longint;cdecl;external;
function SSL_CTX_set_default_verify_file(ctx:PSSL_CTX):longint;cdecl;external;
function SSL_CTX_set_default_verify_store(ctx:PSSL_CTX):longint;cdecl;external;
(* Const before type ignored *)
function SSL_CTX_load_verify_file(ctx:PSSL_CTX; CAfile:Pchar):longint;cdecl;external;
(* Const before type ignored *)
function SSL_CTX_load_verify_dir(ctx:PSSL_CTX; CApath:Pchar):longint;cdecl;external;
(* Const before type ignored *)
function SSL_CTX_load_verify_store(ctx:PSSL_CTX; CAstore:Pchar):longint;cdecl;external;
(* Const before type ignored *)
(* Const before type ignored *)
function SSL_CTX_load_verify_locations(ctx:PSSL_CTX; CAfile:Pchar; CApath:Pchar):longint;cdecl;external;
    { just peek at pointer  }
    const
      SSL_get0_session = SSL_get_session;      
(* Const before type ignored *)

function SSL_get_session(ssl:PSSL):PSSL_SESSION;cdecl;external;
function SSL_get1_session(ssl:PSSL):PSSL_SESSION;cdecl;external;
    { obtain a reference count  }
(* Const before type ignored *)
function SSL_get_SSL_CTX(ssl:PSSL):PSSL_CTX;cdecl;external;
function SSL_set_SSL_CTX(ssl:PSSL; ctx:PSSL_CTX):PSSL_CTX;cdecl;external;
(* Const before type ignored *)
procedure SSL_set_info_callback(ssl:PSSL; cb:procedure (ssl:PSSL; _type:longint; val:longint));cdecl;external;
(* Const before type ignored *)
(* Const before type ignored *)
function SSL_get_info_callback(ssl:PSSL):procedure (ssl:PSSL; _type:longint; val:longint);cdecl;external;
(* Const before type ignored *)
function SSL_get_state(ssl:PSSL):TOSSL_HANDSHAKE_STATE;cdecl;external;
procedure SSL_set_verify_result(ssl:PSSL; v:longint);cdecl;external;
(* Const before type ignored *)
function SSL_get_verify_result(ssl:PSSL):longint;cdecl;external;
(* error 
 STACK_OF(X509) *SSL_get0_verified_chain(const SSL *s);
 in declarator_list *)
(* Const before type ignored *)
function SSL_get_client_random(ssl:PSSL; out:Pbyte; outlen:Tsize_t):Tsize_t;cdecl;external;
(* Const before type ignored *)
function SSL_get_server_random(ssl:PSSL; out:Pbyte; outlen:Tsize_t):Tsize_t;cdecl;external;
(* Const before type ignored *)
function SSL_SESSION_get_master_key(sess:PSSL_SESSION; out:Pbyte; outlen:Tsize_t):Tsize_t;cdecl;external;
(* Const before type ignored *)
function SSL_SESSION_set1_master_key(sess:PSSL_SESSION; in:Pbyte; len:Tsize_t):longint;cdecl;external;
(* Const before type ignored *)
function SSL_SESSION_get_max_fragment_length(sess:PSSL_SESSION):Tuint8_t;cdecl;external;
    { was #define dname(params) para_def_expr }
    { argument types are unknown }
    { return type might be wrong }   
    function SSL_get_ex_new_index(l,p,newf,dupf,freef : longint) : longint;    

function SSL_set_ex_data(ssl:PSSL; idx:longint; data:pointer):longint;cdecl;external;
(* Const before type ignored *)
function SSL_get_ex_data(ssl:PSSL; idx:longint):pointer;cdecl;external;
    { was #define dname(params) para_def_expr }
    { argument types are unknown }
    { return type might be wrong }   
    function SSL_SESSION_get_ex_new_index(l,p,newf,dupf,freef : longint) : longint;    

function SSL_SESSION_set_ex_data(ss:PSSL_SESSION; idx:longint; data:pointer):longint;cdecl;external;
(* Const before type ignored *)
function SSL_SESSION_get_ex_data(ss:PSSL_SESSION; idx:longint):pointer;cdecl;external;
    { was #define dname(params) para_def_expr }
    { argument types are unknown }
    { return type might be wrong }   
    function SSL_CTX_get_ex_new_index(l,p,newf,dupf,freef : longint) : longint;    

function SSL_CTX_set_ex_data(ssl:PSSL_CTX; idx:longint; data:pointer):longint;cdecl;external;
(* Const before type ignored *)
function SSL_CTX_get_ex_data(ssl:PSSL_CTX; idx:longint):pointer;cdecl;external;
function SSL_get_ex_data_X509_STORE_CTX_idx:longint;cdecl;external;
procedure SSL_CTX_set_default_read_buffer_len(ctx:PSSL_CTX; len:Tsize_t);cdecl;external;
procedure SSL_set_default_read_buffer_len(s:PSSL; len:Tsize_t);cdecl;external;
(* Const before type ignored *)
(* Const before type ignored *)
function SSL_get_current_compression(s:PSSL):PCOMP_METHOD;cdecl;external;
(* Const before type ignored *)
(* Const before type ignored *)
function SSL_get_current_expansion(s:PSSL):PCOMP_METHOD;cdecl;external;
(* Const before type ignored *)
(* Const before type ignored *)
function SSL_COMP_get_name(comp:PCOMP_METHOD):Pchar;cdecl;external;
(* Const before type ignored *)
(* Const before type ignored *)
function SSL_COMP_get0_name(comp:PSSL_COMP):Pchar;cdecl;external;
(* Const before type ignored *)
function SSL_COMP_get_id(comp:PSSL_COMP):longint;cdecl;external;
(* error 
STACK_OF(SSL_COMP) *SSL_COMP_get_compression_methods(void);
 in declarator_list *)
(* error 
 STACK_OF(SSL_COMP) *SSL_COMP_set0_compression_methods(STACK_OF(SSL_COMP)
 in declarator_list *)
function SSL_COMP_add_compression_method(id:longint; cm:PCOMP_METHOD):longint;cdecl;external;
(* Const before type ignored *)
(* Const before type ignored *)
function SSL_CIPHER_find(ssl:PSSL; ptr:Pbyte):PSSL_CIPHER;cdecl;external;
(* Const before type ignored *)
function SSL_CIPHER_get_cipher_nid(c:PSSL_CIPHER):longint;cdecl;external;
(* Const before type ignored *)
function SSL_CIPHER_get_digest_nid(c:PSSL_CIPHER):longint;cdecl;external;
(* Const before type ignored *)
function SSL_bytes_to_cipher_list(s:PSSL; bytes:Pbyte; len:Tsize_t; isv2format:longint; sk:PPstack_st_SSL_CIPHERtype; 
               scsvs:PPstack_st_SSL_CIPHERtype):longint;cdecl;external;
    { TLS extensions functions  }
function SSL_set_session_ticket_ext(s:PSSL; ext_data:pointer; ext_len:longint):longint;cdecl;external;
function SSL_set_session_ticket_ext_cb(s:PSSL; cb:Ttls_session_ticket_ext_cb_fn; arg:pointer):longint;cdecl;external;
    { Pre-shared secret session resumption functions  }
function SSL_set_session_secret_cb(s:PSSL; session_secret_cb:Ttls_session_secret_cb_fn; arg:pointer):longint;cdecl;external;
procedure SSL_CTX_set_not_resumable_session_callback(ctx:PSSL_CTX; cb:function (ssl:PSSL; is_forward_secure:longint):longint);cdecl;external;
procedure SSL_set_not_resumable_session_callback(ssl:PSSL; cb:function (ssl:PSSL; is_forward_secure:longint):longint);cdecl;external;
procedure SSL_CTX_set_record_padding_callback(ctx:PSSL_CTX; cb:function (ssl:PSSL; _type:longint; len:Tsize_t; arg:pointer):Tsize_t);cdecl;external;
procedure SSL_CTX_set_record_padding_callback_arg(ctx:PSSL_CTX; arg:pointer);cdecl;external;
(* Const before type ignored *)
function SSL_CTX_get_record_padding_callback_arg(ctx:PSSL_CTX):pointer;cdecl;external;
function SSL_CTX_set_block_padding(ctx:PSSL_CTX; block_size:Tsize_t):longint;cdecl;external;
function SSL_set_record_padding_callback(ssl:PSSL; cb:function (ssl:PSSL; _type:longint; len:Tsize_t; arg:pointer):Tsize_t):longint;cdecl;external;
procedure SSL_set_record_padding_callback_arg(ssl:PSSL; arg:pointer);cdecl;external;
(* Const before type ignored *)
function SSL_get_record_padding_callback_arg(ssl:PSSL):pointer;cdecl;external;
function SSL_set_block_padding(ssl:PSSL; block_size:Tsize_t):longint;cdecl;external;
function SSL_set_num_tickets(s:PSSL; num_tickets:Tsize_t):longint;cdecl;external;
(* Const before type ignored *)
function SSL_get_num_tickets(s:PSSL):Tsize_t;cdecl;external;
function SSL_CTX_set_num_tickets(ctx:PSSL_CTX; num_tickets:Tsize_t):longint;cdecl;external;
(* Const before type ignored *)
function SSL_CTX_get_num_tickets(ctx:PSSL_CTX):Tsize_t;cdecl;external;
(* Const before type ignored *)
function SSL_session_reused(s:PSSL):longint;cdecl;external;
(* Const before type ignored *)
function SSL_is_server(s:PSSL):longint;cdecl;external;
function SSL_CONF_CTX_new:PSSL_CONF_CTX;cdecl;external;
function SSL_CONF_CTX_finish(cctx:PSSL_CONF_CTX):longint;cdecl;external;
procedure SSL_CONF_CTX_free(cctx:PSSL_CONF_CTX);cdecl;external;
function SSL_CONF_CTX_set_flags(cctx:PSSL_CONF_CTX; flags:dword):dword;cdecl;external;
function SSL_CONF_CTX_clear_flags(cctx:PSSL_CONF_CTX; flags:dword):dword;cdecl;external;
(* Const before type ignored *)
function SSL_CONF_CTX_set1_prefix(cctx:PSSL_CONF_CTX; pre:Pchar):longint;cdecl;external;
procedure SSL_CONF_CTX_set_ssl(cctx:PSSL_CONF_CTX; ssl:PSSL);cdecl;external;
procedure SSL_CONF_CTX_set_ssl_ctx(cctx:PSSL_CONF_CTX; ctx:PSSL_CTX);cdecl;external;
(* Const before type ignored *)
(* Const before type ignored *)
function SSL_CONF_cmd(cctx:PSSL_CONF_CTX; cmd:Pchar; value:Pchar):longint;cdecl;external;
function SSL_CONF_cmd_argv(cctx:PSSL_CONF_CTX; pargc:Plongint; pargv:PPPchar):longint;cdecl;external;
(* Const before type ignored *)
function SSL_CONF_cmd_value_type(cctx:PSSL_CONF_CTX; cmd:Pchar):longint;cdecl;external;
procedure SSL_add_ssl_module;cdecl;external;
(* Const before type ignored *)
function SSL_config(s:PSSL; name:Pchar):longint;cdecl;external;
(* Const before type ignored *)
function SSL_CTX_config(ctx:PSSL_CTX; name:Pchar):longint;cdecl;external;
{$ifndef OPENSSL_NO_SSL_TRACE}
(* Const before type ignored *)

procedure SSL_trace(write_p:longint; version:longint; content_type:longint; buf:pointer; len:Tsize_t; 
                ssl:PSSL; arg:pointer);cdecl;external;
{$endif}
{$ifndef OPENSSL_NO_SOCK}

function DTLSv1_listen(s:PSSL; client:PBIO_ADDR):longint;cdecl;external;
{$endif}
{$ifndef OPENSSL_NO_CT}
    {
     * A callback for verifying that the received SCTs are sufficient.
     * Expected to return 1 if they are sufficient, otherwise 0.
     * May return a negative integer if an error occurs.
     * A connection should be aborted if the SCTs are deemed insufficient.
      }
(* Const before type ignored *)
(* Const before type ignored *)
(* error 
                                    const STACK_OF(SCT) *scts, void *arg);
in declaration at line 1762 *)
    {
     * Sets a |callback| that is invoked upon receipt of ServerHelloDone to validate
     * the received SCTs.
     * If the callback returns a non-positive result, the connection is terminated.
     * Call this function before beginning a handshake.
     * If a NULL |callback| is provided, SCT validation is disabled.
     * |arg| is arbitrary userdata that will be passed to the callback whenever it
     * is invoked. Ownership of |arg| remains with the caller.
     *
     * NOTE: A side-effect of setting a CT callback is that an OCSP stapled response
     *       will be requested.
      }

function SSL_set_ct_validation_callback(s:PSSL; callback:Tssl_ct_validation_cb; arg:pointer):longint;cdecl;external;
function SSL_CTX_set_ct_validation_callback(ctx:PSSL_CTX; callback:Tssl_ct_validation_cb; arg:pointer):longint;cdecl;external;
    {
     * The validation type enumerates the available behaviours of the built-in SSL
     * CT validation callback selected via SSL_enable_ct() and SSL_CTX_enable_ct().
     * The underlying callback is a static function in libssl.
      }
(* error 
enum {
in declaration at line 1790 *)
    {
     * Enable CT by setting up a callback that implements one of the built-in
     * validation variants.  The SSL_CT_VALIDATION_PERMISSIVE variant always
     * continues the handshake, the application can make appropriate decisions at
     * handshake completion.  The SSL_CT_VALIDATION_STRICT variant requires at
     * least one valid SCT, or else handshake termination will be requested.  The
     * handshake may continue anyway if SSL_VERIFY_NONE is in effect.
      }
function SSL_enable_ct(s:PSSL; validation_mode:longint):longint;cdecl;external;
function SSL_CTX_enable_ct(ctx:PSSL_CTX; validation_mode:longint):longint;cdecl;external;
    {
     * Report whether a non-NULL callback is enabled.
      }
(* Const before type ignored *)
function SSL_ct_is_enabled(s:PSSL):longint;cdecl;external;
(* Const before type ignored *)
function SSL_CTX_ct_is_enabled(ctx:PSSL_CTX):longint;cdecl;external;
    { Gets the SCTs received from a connection  }
(* Const before type ignored *)
(* error 
const STACK_OF(SCT) *SSL_get0_peer_scts(SSL *s);
 in declarator_list *)
    {
     * Loads the CT log list from the default location.
     * If a CTLOG_STORE has previously been set using SSL_CTX_set_ctlog_store,
     * the log information loaded from this file will be appended to the
     * CTLOG_STORE.
     * Returns 1 on success, 0 otherwise.
      }
function SSL_CTX_set_default_ctlog_list_file(ctx:PSSL_CTX):longint;cdecl;external;
    {
     * Loads the CT log list from the specified file path.
     * If a CTLOG_STORE has previously been set using SSL_CTX_set_ctlog_store,
     * the log information loaded from this file will be appended to the
     * CTLOG_STORE.
     * Returns 1 on success, 0 otherwise.
      }
(* Const before type ignored *)
function SSL_CTX_set_ctlog_list_file(ctx:PSSL_CTX; path:Pchar):longint;cdecl;external;
    {
     * Sets the CT log list used by all SSL connections created from this SSL_CTX.
     * Ownership of the CTLOG_STORE is transferred to the SSL_CTX.
      }
procedure SSL_CTX_set0_ctlog_store(ctx:PSSL_CTX; logs:PCTLOG_STORE);cdecl;external;
    {
     * Gets the CT log list used by all SSL connections created from this SSL_CTX.
     * This will be NULL unless one of the following functions has been called:
     * - SSL_CTX_set_default_ctlog_list_file
     * - SSL_CTX_set_ctlog_list_file
     * - SSL_CTX_set_ctlog_store
      }
(* Const before type ignored *)
(* Const before type ignored *)
function SSL_CTX_get0_ctlog_store(ctx:PSSL_CTX):PCTLOG_STORE;cdecl;external;
{$endif}
    { OPENSSL_NO_CT  }
    { What the "other" parameter contains in security callback  }
    { Mask for type  }

    const
      SSL_SECOP_OTHER_TYPE = $ffff0000;      
      SSL_SECOP_OTHER_NONE = 0;      
      SSL_SECOP_OTHER_CIPHER = 1 shl 16;      
      SSL_SECOP_OTHER_CURVE = 2 shl 16;      
      SSL_SECOP_OTHER_DH = 3 shl 16;      
      SSL_SECOP_OTHER_PKEY = 4 shl 16;      
      SSL_SECOP_OTHER_SIGALG = 5 shl 16;      
      SSL_SECOP_OTHER_CERT = 6 shl 16;      
    { Indicated operation refers to peer key or certificate  }
      SSL_SECOP_PEER = $1000;      
    { Values for "op" parameter in security callback  }
    { Called to filter ciphers  }
    { Ciphers client supports  }
      SSL_SECOP_CIPHER_SUPPORTED = 1 or SSL_SECOP_OTHER_CIPHER;      
    { Cipher shared by client/server  }
      SSL_SECOP_CIPHER_SHARED = 2 or SSL_SECOP_OTHER_CIPHER;      
    { Sanity check of cipher server selects  }
      SSL_SECOP_CIPHER_CHECK = 3 or SSL_SECOP_OTHER_CIPHER;      
    { Curves supported by client  }
      SSL_SECOP_CURVE_SUPPORTED = 4 or SSL_SECOP_OTHER_CURVE;      
    { Curves shared by client/server  }
      SSL_SECOP_CURVE_SHARED = 5 or SSL_SECOP_OTHER_CURVE;      
    { Sanity check of curve server selects  }
      SSL_SECOP_CURVE_CHECK = 6 or SSL_SECOP_OTHER_CURVE;      
    { Temporary DH key  }
      SSL_SECOP_TMP_DH = 7 or SSL_SECOP_OTHER_PKEY;      
    { SSL/TLS version  }
      SSL_SECOP_VERSION = 9 or SSL_SECOP_OTHER_NONE;      
    { Session tickets  }
      SSL_SECOP_TICKET = 10 or SSL_SECOP_OTHER_NONE;      
    { Supported signature algorithms sent to peer  }
      SSL_SECOP_SIGALG_SUPPORTED = 11 or SSL_SECOP_OTHER_SIGALG;      
    { Shared signature algorithm  }
      SSL_SECOP_SIGALG_SHARED = 12 or SSL_SECOP_OTHER_SIGALG;      
    { Sanity check signature algorithm allowed  }
      SSL_SECOP_SIGALG_CHECK = 13 or SSL_SECOP_OTHER_SIGALG;      
    { Used to get mask of supported public key signature algorithms  }
      SSL_SECOP_SIGALG_MASK = 14 or SSL_SECOP_OTHER_SIGALG;      
    { Use to see if compression is allowed  }
      SSL_SECOP_COMPRESSION = 15 or SSL_SECOP_OTHER_NONE;      
    { EE key in certificate  }
      SSL_SECOP_EE_KEY = 16 or SSL_SECOP_OTHER_CERT;      
    { CA key in certificate  }
      SSL_SECOP_CA_KEY = 17 or SSL_SECOP_OTHER_CERT;      
    { CA digest algorithm in certificate  }
      SSL_SECOP_CA_MD = 18 or SSL_SECOP_OTHER_CERT;      
    { Peer EE key in certificate  }
      SSL_SECOP_PEER_EE_KEY = SSL_SECOP_EE_KEY or SSL_SECOP_PEER;      
    { Peer CA key in certificate  }
      SSL_SECOP_PEER_CA_KEY = SSL_SECOP_CA_KEY or SSL_SECOP_PEER;      
    { Peer CA digest algorithm in certificate  }
      SSL_SECOP_PEER_CA_MD = SSL_SECOP_CA_MD or SSL_SECOP_PEER;      

procedure SSL_set_security_level(s:PSSL; level:longint);cdecl;external;
(* Const before type ignored *)
function SSL_get_security_level(s:PSSL):longint;cdecl;external;
(* Const before type ignored *)
(* Const before type ignored *)
procedure SSL_set_security_callback(s:PSSL; cb:function (s:PSSL; ctx:PSSL_CTX; op:longint; bits:longint; nid:longint; 
                           other:pointer; ex:pointer):longint);cdecl;external;
(* Const before type ignored *)
(* Const before type ignored *)
(* Const before type ignored *)
function SSL_get_security_callback(s:PSSL):function (s:PSSL; ctx:PSSL_CTX; op:longint; bits:longint; nid:longint; 
                        other:pointer; ex:pointer):longint;cdecl;external;
procedure SSL_set0_security_ex_data(s:PSSL; ex:pointer);cdecl;external;
(* Const before type ignored *)
function SSL_get0_security_ex_data(s:PSSL):pointer;cdecl;external;
procedure SSL_CTX_set_security_level(ctx:PSSL_CTX; level:longint);cdecl;external;
(* Const before type ignored *)
function SSL_CTX_get_security_level(ctx:PSSL_CTX):longint;cdecl;external;
(* Const before type ignored *)
(* Const before type ignored *)
procedure SSL_CTX_set_security_callback(ctx:PSSL_CTX; cb:function (s:PSSL; ctx:PSSL_CTX; op:longint; bits:longint; nid:longint; 
                           other:pointer; ex:pointer):longint);cdecl;external;
(* Const before type ignored *)
(* Const before type ignored *)
(* Const before type ignored *)
function SSL_CTX_get_security_callback(ctx:PSSL_CTX):function (s:PSSL; ctx:PSSL_CTX; op:longint; bits:longint; nid:longint; 
                        other:pointer; ex:pointer):longint;cdecl;external;
procedure SSL_CTX_set0_security_ex_data(ctx:PSSL_CTX; ex:pointer);cdecl;external;
(* Const before type ignored *)
function SSL_CTX_get0_security_ex_data(ctx:PSSL_CTX):pointer;cdecl;external;
    { OPENSSL_INIT flag 0x010000 reserved for internal use  }
    const
      OPENSSL_INIT_NO_LOAD_SSL_STRINGS = $00100000;      
      OPENSSL_INIT_LOAD_SSL_STRINGS = $00200000;      
      OPENSSL_INIT_SSL_DEFAULT = OPENSSL_INIT_LOAD_SSL_STRINGS or OPENSSL_INIT_LOAD_CRYPTO_STRINGS;      
(* Const before type ignored *)

function OPENSSL_init_ssl(opts:Tuint64_t; settings:POPENSSL_INIT_SETTINGS):longint;cdecl;external;
{$ifndef OPENSSL_NO_UNIT_TEST}
(* Const before type ignored *)

function SSL_test_functions:Popenssl_ssl_test_functions;cdecl;external;
{$endif}

function SSL_free_buffers(ssl:PSSL):longint;cdecl;external;
function SSL_alloc_buffers(ssl:PSSL):longint;cdecl;external;
    { Status codes passed to the decrypt session ticket callback. Some of these
     * are for internal use only and are never passed to the callback.  }
    type
      PSSL_TICKET_STATUS = ^TSSL_TICKET_STATUS;
      TSSL_TICKET_STATUS = longint;
    { Support for ticket appdata  }
    { fatal error, malloc failure  }

    const
      SSL_TICKET_FATAL_ERR_MALLOC = 0;      
    { fatal error, either from parsing or decrypting the ticket  }
      SSL_TICKET_FATAL_ERR_OTHER = 1;      
    { No ticket present  }
      SSL_TICKET_NONE = 2;      
    { Empty ticket present  }
      SSL_TICKET_EMPTY = 3;      
    { the ticket couldn't be decrypted  }
      SSL_TICKET_NO_DECRYPT = 4;      
    { a ticket was successfully decrypted  }
      SSL_TICKET_SUCCESS = 5;      
    { same as above but the ticket needs to be renewed  }
      SSL_TICKET_SUCCESS_RENEW = 6;      
    { Return codes for the decrypt session ticket callback  }
    type
      PSSL_TICKET_RETURN = ^TSSL_TICKET_RETURN;
      TSSL_TICKET_RETURN = longint;
    { An error occurred  }

    const
      SSL_TICKET_RETURN_ABORT = 0;      
    { Do not use the ticket, do not send a renewed ticket to the client  }
      SSL_TICKET_RETURN_IGNORE = 1;      
    { Do not use the ticket, send a renewed ticket to the client  }
      SSL_TICKET_RETURN_IGNORE_RENEW = 2;      
    { Use the ticket, do not send a renewed ticket to the client  }
      SSL_TICKET_RETURN_USE = 3;      
    { Use the ticket, send a renewed ticket to the client  }
      SSL_TICKET_RETURN_USE_RENEW = 4;      
    type

      TSSL_CTX_generate_session_ticket_fn = function (s:PSSL; arg:pointer):longint;cdecl;
(* Const before type ignored *)

      TSSL_CTX_decrypt_session_ticket_fn = function (s:PSSL; ss:PSSL_SESSION; keyname:Pbyte; keyname_length:Tsize_t; status:TSSL_TICKET_STATUS; 
                   arg:pointer):TSSL_TICKET_RETURN;cdecl;

function SSL_CTX_set_session_ticket_cb(ctx:PSSL_CTX; gen_cb:TSSL_CTX_generate_session_ticket_fn; dec_cb:TSSL_CTX_decrypt_session_ticket_fn; arg:pointer):longint;cdecl;external;
(* Const before type ignored *)
function SSL_SESSION_set1_ticket_appdata(ss:PSSL_SESSION; data:pointer; len:Tsize_t):longint;cdecl;external;
function SSL_SESSION_get0_ticket_appdata(ss:PSSL_SESSION; data:Ppointer; len:Psize_t):longint;cdecl;external;
    type

      TDTLS_timer_cb = function (s:PSSL; timer_us:dword):dword;cdecl;

procedure DTLS_set_timer_cb(s:PSSL; cb:TDTLS_timer_cb);cdecl;external;
    type

      TSSL_allow_early_data_cb_fn = function (s:PSSL; arg:pointer):longint;cdecl;

procedure SSL_CTX_set_allow_early_data_cb(ctx:PSSL_CTX; cb:TSSL_allow_early_data_cb_fn; arg:pointer);cdecl;external;
procedure SSL_set_allow_early_data_cb(s:PSSL; cb:TSSL_allow_early_data_cb_fn; arg:pointer);cdecl;external;
    { store the default cipher strings inside the library  }
(* Const before type ignored *)
function OSSL_default_cipher_list:Pchar;cdecl;external;
(* Const before type ignored *)
function OSSL_default_ciphersuites:Pchar;cdecl;external;
{$ifdef  __cplusplus}
(* error 
}
{$endif}
{$endif}

implementation

    { was #define dname(params) para_def_expr }
    { argument types are unknown }
    { return type might be wrong }   
    function SSL_OP_BIT(n : longint) : longint;
    begin
      SSL_OP_BIT:=(Tuint64_t(1)) shl (Tuint64_t(n));
    end;

    { was #define dname def_expr }
    function SSL_OP_NO_EXTENDED_MASTER_SECRET : longint; { return type might be wrong }
      begin
        SSL_OP_NO_EXTENDED_MASTER_SECRET:=SSL_OP_BIT(0);
      end;

    { was #define dname def_expr }
    function SSL_OP_CLEANSE_PLAINTEXT : longint; { return type might be wrong }
      begin
        SSL_OP_CLEANSE_PLAINTEXT:=SSL_OP_BIT(1);
      end;

    { was #define dname def_expr }
    function SSL_OP_LEGACY_SERVER_CONNECT : longint; { return type might be wrong }
      begin
        SSL_OP_LEGACY_SERVER_CONNECT:=SSL_OP_BIT(2);
      end;

    { was #define dname def_expr }
    function SSL_OP_ENABLE_KTLS : longint; { return type might be wrong }
      begin
        SSL_OP_ENABLE_KTLS:=SSL_OP_BIT(3);
      end;

    { was #define dname def_expr }
    function SSL_OP_TLSEXT_PADDING : longint; { return type might be wrong }
      begin
        SSL_OP_TLSEXT_PADDING:=SSL_OP_BIT(4);
      end;

    { was #define dname def_expr }
    function SSL_OP_SAFARI_ECDHE_ECDSA_BUG : longint; { return type might be wrong }
      begin
        SSL_OP_SAFARI_ECDHE_ECDSA_BUG:=SSL_OP_BIT(6);
      end;

    { was #define dname def_expr }
    function SSL_OP_IGNORE_UNEXPECTED_EOF : longint; { return type might be wrong }
      begin
        SSL_OP_IGNORE_UNEXPECTED_EOF:=SSL_OP_BIT(7);
      end;

    { was #define dname def_expr }
    function SSL_OP_ALLOW_CLIENT_RENEGOTIATION : longint; { return type might be wrong }
      begin
        SSL_OP_ALLOW_CLIENT_RENEGOTIATION:=SSL_OP_BIT(8);
      end;

    { was #define dname def_expr }
    function SSL_OP_DISABLE_TLSEXT_CA_NAMES : longint; { return type might be wrong }
      begin
        SSL_OP_DISABLE_TLSEXT_CA_NAMES:=SSL_OP_BIT(9);
      end;

    { was #define dname def_expr }
    function SSL_OP_ALLOW_NO_DHE_KEX : longint; { return type might be wrong }
      begin
        SSL_OP_ALLOW_NO_DHE_KEX:=SSL_OP_BIT(10);
      end;

    { was #define dname def_expr }
    function SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS : longint; { return type might be wrong }
      begin
        SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS:=SSL_OP_BIT(11);
      end;

    { was #define dname def_expr }
    function SSL_OP_NO_QUERY_MTU : longint; { return type might be wrong }
      begin
        SSL_OP_NO_QUERY_MTU:=SSL_OP_BIT(12);
      end;

    { was #define dname def_expr }
    function SSL_OP_COOKIE_EXCHANGE : longint; { return type might be wrong }
      begin
        SSL_OP_COOKIE_EXCHANGE:=SSL_OP_BIT(13);
      end;

    { was #define dname def_expr }
    function SSL_OP_NO_TICKET : longint; { return type might be wrong }
      begin
        SSL_OP_NO_TICKET:=SSL_OP_BIT(14);
      end;

    { was #define dname def_expr }
    function SSL_OP_CISCO_ANYCONNECT : longint; { return type might be wrong }
      begin
        SSL_OP_CISCO_ANYCONNECT:=SSL_OP_BIT(15);
      end;

    { was #define dname def_expr }
    function SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION : longint; { return type might be wrong }
      begin
        SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION:=SSL_OP_BIT(16);
      end;

    { was #define dname def_expr }
    function SSL_OP_NO_COMPRESSION : longint; { return type might be wrong }
      begin
        SSL_OP_NO_COMPRESSION:=SSL_OP_BIT(17);
      end;

    { was #define dname def_expr }
    function SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION : longint; { return type might be wrong }
      begin
        SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION:=SSL_OP_BIT(18);
      end;

    { was #define dname def_expr }
    function SSL_OP_NO_ENCRYPT_THEN_MAC : longint; { return type might be wrong }
      begin
        SSL_OP_NO_ENCRYPT_THEN_MAC:=SSL_OP_BIT(19);
      end;

    { was #define dname def_expr }
    function SSL_OP_ENABLE_MIDDLEBOX_COMPAT : longint; { return type might be wrong }
      begin
        SSL_OP_ENABLE_MIDDLEBOX_COMPAT:=SSL_OP_BIT(20);
      end;

    { was #define dname def_expr }
    function SSL_OP_PRIORITIZE_CHACHA : longint; { return type might be wrong }
      begin
        SSL_OP_PRIORITIZE_CHACHA:=SSL_OP_BIT(21);
      end;

    { was #define dname def_expr }
    function SSL_OP_CIPHER_SERVER_PREFERENCE : longint; { return type might be wrong }
      begin
        SSL_OP_CIPHER_SERVER_PREFERENCE:=SSL_OP_BIT(22);
      end;

    { was #define dname def_expr }
    function SSL_OP_TLS_ROLLBACK_BUG : longint; { return type might be wrong }
      begin
        SSL_OP_TLS_ROLLBACK_BUG:=SSL_OP_BIT(23);
      end;

    { was #define dname def_expr }
    function SSL_OP_NO_ANTI_REPLAY : longint; { return type might be wrong }
      begin
        SSL_OP_NO_ANTI_REPLAY:=SSL_OP_BIT(24);
      end;

    { was #define dname def_expr }
    function SSL_OP_NO_SSLv3 : longint; { return type might be wrong }
      begin
        SSL_OP_NO_SSLv3:=SSL_OP_BIT(25);
      end;

    { was #define dname def_expr }
    function SSL_OP_NO_TLSv1 : longint; { return type might be wrong }
      begin
        SSL_OP_NO_TLSv1:=SSL_OP_BIT(26);
      end;

    { was #define dname def_expr }
    function SSL_OP_NO_TLSv1_2 : longint; { return type might be wrong }
      begin
        SSL_OP_NO_TLSv1_2:=SSL_OP_BIT(27);
      end;

    { was #define dname def_expr }
    function SSL_OP_NO_TLSv1_1 : longint; { return type might be wrong }
      begin
        SSL_OP_NO_TLSv1_1:=SSL_OP_BIT(28);
      end;

    { was #define dname def_expr }
    function SSL_OP_NO_TLSv1_3 : longint; { return type might be wrong }
      begin
        SSL_OP_NO_TLSv1_3:=SSL_OP_BIT(29);
      end;

    { was #define dname def_expr }
    function SSL_OP_NO_DTLSv1 : longint; { return type might be wrong }
      begin
        SSL_OP_NO_DTLSv1:=SSL_OP_BIT(26);
      end;

    { was #define dname def_expr }
    function SSL_OP_NO_DTLSv1_2 : longint; { return type might be wrong }
      begin
        SSL_OP_NO_DTLSv1_2:=SSL_OP_BIT(27);
      end;

    { was #define dname def_expr }
    function SSL_OP_NO_RENEGOTIATION : longint; { return type might be wrong }
      begin
        SSL_OP_NO_RENEGOTIATION:=SSL_OP_BIT(30);
      end;

    { was #define dname def_expr }
    function SSL_OP_CRYPTOPRO_TLSEXT_BUG : longint; { return type might be wrong }
      begin
        SSL_OP_CRYPTOPRO_TLSEXT_BUG:=SSL_OP_BIT(31);
      end;

    { was #define dname(params) para_def_expr }
    { argument types are unknown }
    { return type might be wrong }   
    function SSL_get_extms_support(s : longint) : longint;
    begin
      SSL_get_extms_support:=SSL_ctrl(s,SSL_CTRL_GET_EXTMS_SUPPORT,0,NULL);
    end;

    { was #define dname(params) para_def_expr }
    { argument types are unknown }
    { return type might be wrong }   
    function SSL_want_nothing(s : longint) : longint;
    begin
      SSL_want_nothing:=(SSL_want(s))=SSL_NOTHING;
    end;

    { was #define dname(params) para_def_expr }
    { argument types are unknown }
    { return type might be wrong }   
    function SSL_want_read(s : longint) : longint;
    begin
      SSL_want_read:=(SSL_want(s))=SSL_READING;
    end;

    { was #define dname(params) para_def_expr }
    { argument types are unknown }
    { return type might be wrong }   
    function SSL_want_write(s : longint) : longint;
    begin
      SSL_want_write:=(SSL_want(s))=SSL_WRITING;
    end;

    { was #define dname(params) para_def_expr }
    { argument types are unknown }
    { return type might be wrong }   
    function SSL_want_x509_lookup(s : longint) : longint;
    begin
      SSL_want_x509_lookup:=(SSL_want(s))=SSL_X509_LOOKUP;
    end;

    { was #define dname(params) para_def_expr }
    { argument types are unknown }
    { return type might be wrong }   
    function SSL_want_retry_verify(s : longint) : longint;
    begin
      SSL_want_retry_verify:=(SSL_want(s))=SSL_RETRY_VERIFY;
    end;

    { was #define dname(params) para_def_expr }
    { argument types are unknown }
    { return type might be wrong }   
    function SSL_want_async(s : longint) : longint;
    begin
      SSL_want_async:=(SSL_want(s))=SSL_ASYNC_PAUSED;
    end;

    { was #define dname(params) para_def_expr }
    { argument types are unknown }
    { return type might be wrong }   
    function SSL_want_async_job(s : longint) : longint;
    begin
      SSL_want_async_job:=(SSL_want(s))=SSL_ASYNC_NO_JOBS;
    end;

    { was #define dname(params) para_def_expr }
    { argument types are unknown }
    { return type might be wrong }   
    function SSL_want_client_hello_cb(s : longint) : longint;
    begin
      SSL_want_client_hello_cb:=(SSL_want(s))=SSL_CLIENT_HELLO_CB;
    end;

    { was #define dname(params) para_def_expr }
    { argument types are unknown }
    { return type might be wrong }   
    function SSL_in_connect_init(a : longint) : longint;
    begin
      SSL_in_connect_init:=(SSL_in_init(a)) and (@( not (SSL_is_server(a))));
    end;

    { was #define dname(params) para_def_expr }
    { argument types are unknown }
    { return type might be wrong }   
    function SSL_in_accept_init(a : longint) : longint;
    begin
      SSL_in_accept_init:=(SSL_in_init(a)) and (@(SSL_is_server(a)));
    end;

    { was #define dname(params) para_def_expr }
    { argument types are unknown }
    { return type might be wrong }   
    function d2i_SSL_SESSION_bio(bp,s_id : longint) : longint;
    begin
      d2i_SSL_SESSION_bio:=ASN1_d2i_bio_of(SSL_SESSION,SSL_SESSION_new,d2i_SSL_SESSION,bp,s_id);
    end;

    { was #define dname(params) para_def_expr }
    { argument types are unknown }
    { return type might be wrong }   
    function i2d_SSL_SESSION_bio(bp,s_id : longint) : longint;
    begin
      i2d_SSL_SESSION_bio:=ASN1_i2d_bio_of(SSL_SESSION,i2d_SSL_SESSION,bp,s_id);
    end;

    { was #define dname(params) para_def_expr }
    { argument types are unknown }
    { return type might be wrong }   
    function SSL_get_ex_new_index(l,p,newf,dupf,freef : longint) : longint;
    begin
      SSL_get_ex_new_index:=CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_SSL,l,p,newf,dupf,freef);
    end;

    { was #define dname(params) para_def_expr }
    { argument types are unknown }
    { return type might be wrong }   
    function SSL_SESSION_get_ex_new_index(l,p,newf,dupf,freef : longint) : longint;
    begin
      SSL_SESSION_get_ex_new_index:=CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_SSL_SESSION,l,p,newf,dupf,freef);
    end;

    { was #define dname(params) para_def_expr }
    { argument types are unknown }
    { return type might be wrong }   
    function SSL_CTX_get_ex_new_index(l,p,newf,dupf,freef : longint) : longint;
    begin
      SSL_CTX_get_ex_new_index:=CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_SSL_CTX,l,p,newf,dupf,freef);
    end;


end.
