
unit rpc;
interface

{
  Automatically converted by H2Pas 1.0.0 from rpc.h
  The following command line parameters were used:
    -p
    -T
    -d
    -c
    -e
    rpc.h
}

{ Pointers to basic pascal types, inserted by h2pas conversion program.}
Type
  PLongint  = ^Longint;
  PSmallInt = ^SmallInt;
  PByte     = ^Byte;
  PWord     = ^Word;
  PDWord    = ^DWord;
  PDouble   = ^Double;

Type
Pchar  = ^char;
Pevbuffer  = ^evbuffer;
Pevent_base  = ^event_base;
Pevhttp  = ^evhttp;
Pevhttp_connection  = ^evhttp_connection;
Pevhttp_request  = ^evhttp_request;
Pevrpc  = ^evrpc;
Pevrpc_base  = ^evrpc_base;
Pevrpc_hook_meta  = ^evrpc_hook_meta;
PEVRPC_HOOK_RESULT  = ^EVRPC_HOOK_RESULT;
PEVRPC_HOOK_TYPE  = ^EVRPC_HOOK_TYPE;
Pevrpc_pool  = ^evrpc_pool;
Pevrpc_req_generic  = ^evrpc_req_generic;
Pevrpc_request_wrapper  = ^evrpc_request_wrapper;
Pevrpc_status  = ^evrpc_status;
Psize_t  = ^size_t;
{$IFDEF FPC}
{$PACKRECORDS C}
{$ENDIF}


{
 * Copyright (c) 2006-2007 Niels Provos <provos@citi.umich.edu>
 * Copyright (c) 2007-2012 Niels Provos and Nick Mathewson
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  }
{$ifndef EVENT2_RPC_H_INCLUDED_}
{$define EVENT2_RPC_H_INCLUDED_}
{ For int types.  }
{$include <event2/util.h>}
{$include <event2/visibility.h>}
{ C++ extern C conditionnal removed }
{* @file rpc.h
 *
 * This header files provides basic support for an RPC server and client.
 *
 * To support RPCs in a server, every supported RPC command needs to be
 * defined and registered.
 *
 * EVRPC_HEADER(SendCommand, Request, Reply);
 *
 *  SendCommand is the name of the RPC command.
 *  Request is the name of a structure generated by event_rpcgen.py.
 *    It contains all parameters relating to the SendCommand RPC.  The
 *    server needs to fill in the Reply structure.
 *  Reply is the name of a structure generated by event_rpcgen.py.  It
 *    contains the answer to the RPC.
 *
 * To register an RPC with an HTTP server, you need to first create an RPC
 * base with:
 *
 *   struct evrpc_base *base = evrpc_init(http);
 *
 * A specific RPC can then be registered with
 *
 * EVRPC_REGISTER(base, SendCommand, Request, Reply,  FunctionCB, arg);
 *
 * when the server receives an appropriately formatted RPC, the user callback
 * is invoked.   The callback needs to fill in the reply structure.
 *
 * void FunctionCB(EVRPC_STRUCT(SendCommand)* rpc, void *arg);
 *
 * To send the reply, call EVRPC_REQUEST_DONE(rpc);
 *
 * See the regression test for an example.
  }
{*
   Determines if the member has been set in the message

   @param msg the message to inspect
   @param member the member variable to test for presences
   @return 1 if it's present or 0 otherwise.
 }
{$ifndef EVENT2_RPC_COMPAT_H_INCLUDED_}
{*
   Assigns a value to the member in the message.

   @param msg the message to which to assign a value
   @param member the name of the member variable
   @param value the value to assign
 }
{*
   Assigns a value to the member in the message.

   @param msg the message to which to assign a value
   @param member the name of the member variable
   @param value the value to assign
   @param len the length of the value
 }
{*
   Returns the value for a member.

   @param msg the message from which to get the value
   @param member the name of the member variable
   @param pvalue a pointer to the variable to hold the value
   @return 0 on success, -1 otherwise.
 }
{*
   Returns the value for a member.

   @param msg the message from which to get the value
   @param member the name of the member variable
   @param pvalue a pointer to the variable to hold the value
   @param plen a pointer to the length of the value
   @return 0 on success, -1 otherwise.
 }
{$endif}
{ EVENT2_RPC_COMPAT_H_INCLUDED_  }
{*
   Adds a value to an array.
 }
type
  Pevbuffer = ^Tevbuffer;
  Tevbuffer = record
      {undefined structure}
    end;

  Pevent_base = ^Tevent_base;
  Tevent_base = record
      {undefined structure}
    end;

  Pevrpc_req_generic = ^Tevrpc_req_generic;
  Tevrpc_req_generic = record
      {undefined structure}
    end;

  Pevrpc_request_wrapper = ^Tevrpc_request_wrapper;
  Tevrpc_request_wrapper = record
      {undefined structure}
    end;

  Pevrpc = ^Tevrpc;
  Tevrpc = record
      {undefined structure}
    end;

{* The type of a specific RPC Message
 *
 * @param rpcname the name of the RPC message
  }
  Pevhttp_request = ^Tevhttp_request;
  Tevhttp_request = record
      {undefined structure}
    end;

  Pevrpc_status = ^Tevrpc_status;
  Tevrpc_status = record
      {undefined structure}
    end;

  Pevrpc_hook_meta = ^Tevrpc_hook_meta;
  Tevrpc_hook_meta = record
      {undefined structure}
    end;

{* Creates the definitions and prototypes for an RPC
 *
 * You need to use EVRPC_HEADER to create structures and function prototypes
 * needed by the server and client implementation.  The structures have to be
 * defined in an .rpc file and converted to source code via event_rpcgen.py
 *
 * @param rpcname the name of the RPC
 * @param reqstruct the name of the RPC request structure
 * @param replystruct the name of the RPC reply structure
 * @see EVRPC_GENERATE()
  }
{ xxxxxxxxxxxxxxxxxxxxxx
#define EVRPC_HEADER(rpcname, reqstruct, rplystruct) \
EVRPC_STRUCT(rpcname) 	\
	struct evrpc_hook_meta *hook_meta; \
	struct reqstruct* request; \
	struct rplystruct* reply; \
	struct evrpc* rpc; \
	struct evhttp_request* http_req; \
	struct evbuffer* rpc_data; \
;								     \
extern \
int evrpc_send_request_##rpcname(struct evrpc_pool *, \
    struct reqstruct *, struct rplystruct *, \
    void (*)(struct evrpc_status *, \
	struct reqstruct *, struct rplystruct *, void *cbarg),	\
    void *);

 }
  Pevrpc_pool = ^Tevrpc_pool;
  Tevrpc_pool = record
      {undefined structure}
    end;

{* use EVRPC_GENERATE instead  }
(* Const before type ignored *)

function evrpc_make_request_ctx(pool:Pevrpc_pool; request:pointer; reply:pointer; rpcname:Pchar; req_marshal:procedure (para1:Pevbuffer; para2:pointer); 
           rpl_clear:procedure (para1:pointer); rpl_unmarshal:function (para1:pointer; para2:Pevbuffer):longint; cb:procedure (para1:Pevrpc_status; para2:pointer; para3:pointer; para4:pointer); cbarg:pointer):Pevrpc_request_wrapper;cdecl;external;
{* Creates a context structure that contains rpc specific information.
 *
 * EVRPC_MAKE_CTX is used to populate a RPC specific context that
 * contains information about marshaling the RPC data types.
 *
 * @param rpcname the name of the RPC
 * @param reqstruct the name of the RPC request structure
 * @param replystruct the name of the RPC reply structure
 * @param pool the evrpc_pool over which to make the request
 * @param request a pointer to the RPC request structure object
 * @param reply a pointer to the RPC reply structure object
 * @param cb the callback function to call when the RPC has completed
 * @param cbarg the argument to supply to the callback
  }
{* Provides access to the HTTP request object underlying an RPC
 *
 * Access to the underlying http object; can be used to look at headers or
 * for getting the remote ip address
 *
 * @param rpc_req the rpc request structure provided to the server callback
 * @return an struct evhttp_request object that can be inspected for
 * HTTP headers or sender information.
  }
{* completes the server response to an rpc request  }
procedure evrpc_request_done(req:Pevrpc_req_generic);cdecl;external;
{* accessors for request and reply  }
function evrpc_get_request(req:Pevrpc_req_generic):pointer;cdecl;external;
function evrpc_get_reply(req:Pevrpc_req_generic):pointer;cdecl;external;
{* Creates the reply to an RPC request
 *
 * EVRPC_REQUEST_DONE is used to answer a request; the reply is expected
 * to have been filled in.  The request and reply pointers become invalid
 * after this call has finished.
 *
 * @param rpc_req the rpc request structure provided to the server callback
  }
type
  Pevrpc_base = ^Tevrpc_base;
  Tevrpc_base = record
      {undefined structure}
    end;

  Pevhttp = ^Tevhttp;
  Tevhttp = record
      {undefined structure}
    end;

{ functions to start up the rpc system  }
{* Creates a new rpc base from which RPC requests can be received
 *
 * @param server a pointer to an existing HTTP server
 * @return a newly allocated evrpc_base struct or NULL if an error occurred
 * @see evrpc_free()
  }

function evrpc_init(server:Pevhttp):Pevrpc_base;cdecl;external;
{*
 * Frees the evrpc base
 *
 * For now, you are responsible for making sure that no rpcs are ongoing.
 *
 * @param base the evrpc_base object to be freed
 * @see evrpc_init
  }
procedure evrpc_free(base:Pevrpc_base);cdecl;external;
{* register RPCs with the HTTP Server
 *
 * registers a new RPC with the HTTP server, each RPC needs to have
 * a unique name under which it can be identified.
 *
 * @param base the evrpc_base structure in which the RPC should be
 *   registered.
 * @param name the name of the RPC
 * @param request the name of the RPC request structure
 * @param reply the name of the RPC reply structure
 * @param callback the callback that should be invoked when the RPC
 * is received.  The callback has the following prototype
 *   void (*callback)(EVRPC_STRUCT(Message)* rpc, void *arg)
 * @param cbarg an additional parameter that can be passed to the callback.
 *   The parameter can be used to carry around state.
  }
{*
   Low level function for registering an RPC with a server.

   Use EVRPC_REGISTER() instead.

   @see EVRPC_REGISTER()
 }
function evrpc_register_rpc(para1:Pevrpc_base; para2:Pevrpc; para3:procedure (para1:Pevrpc_req_generic; para2:pointer); para4:pointer):longint;cdecl;external;
{*
 * Unregisters an already registered RPC
 *
 * @param base the evrpc_base object from which to unregister an RPC
 * @param name the name of the rpc to unregister
 * @return -1 on error or 0 when successful.
 * @see EVRPC_REGISTER()
  }
(* Const before type ignored *)
function evrpc_unregister_rpc(base:Pevrpc_base; name:Pchar):longint;cdecl;external;
{
 * Client-side RPC support
  }
type
  Pevhttp_connection = ^Tevhttp_connection;
  Tevhttp_connection = record
      {undefined structure}
    end;

  Pevrpc_status = ^Tevrpc_status;
  Tevrpc_status = record
      {undefined structure}
    end;

{* launches an RPC and sends it to the server
 *
 * EVRPC_MAKE_REQUEST() is used by the client to send an RPC to the server.
 *
 * @param name the name of the RPC
 * @param pool the evrpc_pool that contains the connection objects over which
 *   the request should be sent.
 * @param request a pointer to the RPC request structure - it contains the
 *   data to be sent to the server.
 * @param reply a pointer to the RPC reply structure.  It is going to be filled
 *   if the request was answered successfully
 * @param cb the callback to invoke when the RPC request has been answered
 * @param cbarg an additional argument to be passed to the client
 * @return 0 on success, -1 on failure
  }
{*
   Makes an RPC request based on the provided context.

   This is a low-level function and should not be used directly
   unless a custom context object is provided.  Use EVRPC_MAKE_REQUEST()
   instead.

   @param ctx a context from EVRPC_MAKE_CTX()
   @returns 0 on success, -1 otherwise.
   @see EVRPC_MAKE_REQUEST(), EVRPC_MAKE_CTX()
 }

function evrpc_make_request(ctx:Pevrpc_request_wrapper):longint;cdecl;external;
{* creates an rpc connection pool
 *
 * a pool has a number of connections associated with it.
 * rpc requests are always made via a pool.
 *
 * @param base a pointer to an struct event_based object; can be left NULL
 *   in singled-threaded applications
 * @return a newly allocated struct evrpc_pool object or NULL if an error
 *   occurred
 * @see evrpc_pool_free()
  }
function evrpc_pool_new(base:Pevent_base):Pevrpc_pool;cdecl;external;
{* frees an rpc connection pool
 *
 * @param pool a pointer to an evrpc_pool allocated via evrpc_pool_new()
 * @see evrpc_pool_new()
  }
procedure evrpc_pool_free(pool:Pevrpc_pool);cdecl;external;
{*
 * Adds a connection over which rpc can be dispatched to the pool.
 *
 * The connection object must have been newly created.
 *
 * @param pool the pool to which to add the connection
 * @param evcon the connection to add to the pool.
  }
procedure evrpc_pool_add_connection(pool:Pevrpc_pool; evcon:Pevhttp_connection);cdecl;external;
{*
 * Removes a connection from the pool.
 *
 * The connection object must have been newly created.
 *
 * @param pool the pool from which to remove the connection
 * @param evcon the connection to remove from the pool.
  }
procedure evrpc_pool_remove_connection(pool:Pevrpc_pool; evcon:Pevhttp_connection);cdecl;external;
{*
 * Sets the timeout in secs after which a request has to complete.  The
 * RPC is completely aborted if it does not complete by then.  Setting
 * the timeout to 0 means that it never timeouts and can be used to
 * implement callback type RPCs.
 *
 * Any connection already in the pool will be updated with the new
 * timeout.  Connections added to the pool after set_timeout has be
 * called receive the pool timeout only if no timeout has been set
 * for the connection itself.
 *
 * @param pool a pointer to a struct evrpc_pool object
 * @param timeout_in_secs the number of seconds after which a request should
 *   timeout and a failure be returned to the callback.
  }
procedure evrpc_pool_set_timeout(pool:Pevrpc_pool; timeout_in_secs:longint);cdecl;external;
{*
 * Hooks for changing the input and output of RPCs; this can be used to
 * implement compression, authentication, encryption, ...
  }
{*< apply the function to an input hook  }
{*< apply the function to an output hook  }
type
  TEVRPC_HOOK_TYPE =  Longint;
  Const
    EVRPC_INPUT = 0;
    EVRPC_OUTPUT = 1;

{$ifndef _WIN32}
{* Deprecated alias for EVRPC_INPUT.  Not available on windows, where it
 * conflicts with platform headers.  }

const
  INPUT = EVRPC_INPUT;  
{* Deprecated alias for EVRPC_OUTPUT.  Not available on windows, where it
 * conflicts with platform headers.  }
  OUTPUT = EVRPC_OUTPUT;  
{$endif}
{*
 * Return value from hook processing functions
  }
{*< indicates the rpc should be terminated  }
{*< continue processing the rpc  }
{*< pause processing request until resumed  }
type
  TEVRPC_HOOK_RESULT =  Longint;
  Const
    EVRPC_TERMINATE = -(1);
    EVRPC_CONTINUE = 0;
    EVRPC_PAUSE = 1;

{* adds a processing hook to either an rpc base or rpc pool
 *
 * If a hook returns TERMINATE, the processing is aborted. On CONTINUE,
 * the request is immediately processed after the hook returns.  If the
 * hook returns PAUSE, request processing stops until evrpc_resume_request()
 * has been called.
 *
 * The add functions return handles that can be used for removing hooks.
 *
 * @param vbase a pointer to either struct evrpc_base or struct evrpc_pool
 * @param hook_type either INPUT or OUTPUT
 * @param cb the callback to call when the hook is activated
 * @param cb_arg an additional argument for the callback
 * @return a handle to the hook so it can be removed later
 * @see evrpc_remove_hook()
  }

function evrpc_add_hook(vbase:pointer; hook_type:TEVRPC_HOOK_TYPE; cb:function (para1:pointer; para2:Pevhttp_request; para3:Pevbuffer; para4:pointer):longint; cb_arg:pointer):pointer;cdecl;external;
{* removes a previously added hook
 *
 * @param vbase a pointer to either struct evrpc_base or struct evrpc_pool
 * @param hook_type either INPUT or OUTPUT
 * @param handle a handle returned by evrpc_add_hook()
 * @return 1 on success or 0 on failure
 * @see evrpc_add_hook()
  }
function evrpc_remove_hook(vbase:pointer; hook_type:TEVRPC_HOOK_TYPE; handle:pointer):longint;cdecl;external;
{* resume a paused request
 *
 * @param vbase a pointer to either struct evrpc_base or struct evrpc_pool
 * @param ctx the context pointer provided to the original hook call
  }
function evrpc_resume_request(vbase:pointer; ctx:pointer; res:TEVRPC_HOOK_RESULT):longint;cdecl;external;
{* adds meta data to request
 *
 * evrpc_hook_add_meta() allows hooks to add meta data to a request. for
 * a client request, the meta data can be inserted by an outgoing request hook
 * and retrieved by the incoming request hook.
 *
 * @param ctx the context provided to the hook call
 * @param key a NUL-terminated c-string
 * @param data the data to be associated with the key
 * @param data_size the size of the data
  }
(* Const before type ignored *)
(* Const before type ignored *)
procedure evrpc_hook_add_meta(ctx:pointer; key:Pchar; data:pointer; data_size:Tsize_t);cdecl;external;
{* retrieves meta data previously associated
 *
 * evrpc_hook_find_meta() can be used to retrieve meta data associated to a
 * request by a previous hook.
 * @param ctx the context provided to the hook call
 * @param key a NUL-terminated c-string
 * @param data pointer to a data pointer that will contain the retrieved data
 * @param data_size pointer to the size of the data
 * @return 0 on success or -1 on failure
  }
(* Const before type ignored *)
function evrpc_hook_find_meta(ctx:pointer; key:Pchar; data:Ppointer; data_size:Psize_t):longint;cdecl;external;
{*
 * returns the connection object associated with the request
 *
 * @param ctx the context provided to the hook call
 * @return a pointer to the evhttp_connection object or NULL if an error
 *   occurred
  }
function evrpc_hook_get_connection(ctx:pointer):Pevhttp_connection;cdecl;external;
{*
   Function for sending a generic RPC request.

   Do not call this function directly, use EVRPC_MAKE_REQUEST() instead.

   @see EVRPC_MAKE_REQUEST()
  }
(* Const before type ignored *)
function evrpc_send_request_generic(pool:Pevrpc_pool; request:pointer; reply:pointer; cb:procedure (para1:Pevrpc_status; para2:pointer; para3:pointer; para4:pointer); cb_arg:pointer; 
           rpcname:Pchar; req_marshal:procedure (para1:Pevbuffer; para2:pointer); rpl_clear:procedure (para1:pointer); rpl_unmarshal:function (para1:pointer; para2:Pevbuffer):longint):longint;cdecl;external;
{*
   Function for registering a generic RPC with the RPC base.

   Do not call this function directly, use EVRPC_REGISTER() instead.

   @see EVRPC_REGISTER()
  }
(* Const before type ignored *)
function evrpc_register_generic(base:Pevrpc_base; name:Pchar; callback:procedure (para1:Pevrpc_req_generic; para2:pointer); cbarg:pointer; req_new:function (para1:pointer):pointer; 
           req_new_arg:pointer; req_free:procedure (para1:pointer); req_unmarshal:function (para1:pointer; para2:Pevbuffer):longint; rpl_new:function (para1:pointer):pointer; rpl_new_arg:pointer; 
           rpl_free:procedure (para1:pointer); rpl_complete:function (para1:pointer):longint; rpl_marshal:procedure (para1:Pevbuffer; para2:pointer)):longint;cdecl;external;
{* accessors for obscure and undocumented functionality  }
function evrpc_request_get_pool(ctx:Pevrpc_request_wrapper):Pevrpc_pool;cdecl;external;
procedure evrpc_request_set_pool(ctx:Pevrpc_request_wrapper; pool:Pevrpc_pool);cdecl;external;
procedure evrpc_request_set_cb(ctx:Pevrpc_request_wrapper; cb:procedure (para1:Pevrpc_status; request:pointer; reply:pointer; arg:pointer); cb_arg:pointer);cdecl;external;
{ C++ end of extern C conditionnal removed }
{$endif}
{ EVENT2_RPC_H_INCLUDED_  }

implementation


end.
