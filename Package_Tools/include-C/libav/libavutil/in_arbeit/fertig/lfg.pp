
unit lfg;
interface

{
  Automatically converted by H2Pas 1.0.0 from lfg.h
  The following command line parameters were used:
    -p
    -T
    -d
    -c
    -e
    lfg.h
}

{ Pointers to basic pascal types, inserted by h2pas conversion program.}
Type
  PLongint  = ^Longint;
  PSmallInt = ^SmallInt;
  PByte     = ^Byte;
  PWord     = ^Word;
  PDWord    = ^DWord;
  PDouble   = ^Double;

Type
PAVLFG  = ^AVLFG;
Puint8_t  = ^uint8_t;
{$IFDEF FPC}
{$PACKRECORDS C}
{$ENDIF}


{
 * Lagged Fibonacci PRNG
 * Copyright (c) 2008 Michael Niedermayer
 *
 * This file is part of FFmpeg.
 *
 * FFmpeg is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * FFmpeg is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with FFmpeg; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  }
{$ifndef AVUTIL_LFG_H}
{$define AVUTIL_LFG_H}
{$include <stdint.h>}
{*
 * Context structure for the Lagged Fibonacci PRNG.
 * The exact layout, types and content of this struct may change and should
 * not be accessed directly. Only its `sizeof()` is guaranteed to stay the same
 * to allow easy instanciation.
  }
type
  PAVLFG = ^TAVLFG;
  TAVLFG = record
      state : array[0..63] of dword;
      index : longint;
    end;

procedure av_lfg_init(c:PAVLFG; seed:dword);cdecl;external;
{*
 * Seed the state of the ALFG using binary data.
 *
 * @return 0 on success, negative value (AVERROR) on failure.
  }
(* Const before type ignored *)
function av_lfg_init_from_data(c:PAVLFG; data:Puint8_t; length:dword):longint;cdecl;external;
{*
 * Get the next random unsigned 32-bit number using an ALFG.
 *
 * Please also consider a simple LCG like state= state*1664525+1013904223,
 * it may be good enough and faster for your specific use case.
  }
{*
 * Get the next two numbers generated by a Box-Muller Gaussian
 * generator using the random numbers issued by lfg.
 *
 * @param lfg pointer to the contex structure
 * @param out array where the two generated numbers are placed
  }
procedure av_bmg_get(lfg:PAVLFG; out:array[0..1] of Tdouble);cdecl;external;
{$endif}
{ AVUTIL_LFG_H  }

implementation


end.
